#+TILE: Ruby Language

* Progress
** Books
| Books                            | Chapter                            | late                                              |
|----------------------------------+------------------------------------+---------------------------------------------------|
| Polished Ruby Programming        | 1                                  | Learning how best to use arrays, hashes, and sets |
| Metaprogramming ruby             | 2                                  | Monday: The Object Mode                           |
| Programming Ruby                 | 24 Metaprogramming                 | 24.1 Objects and Classes                          |
| Effective Testing - RSpec3       | Testing in Isolation: Unit Specs   | Handling Failure                                  |
| Confident Ruby                   | Collecting input                   | 3.8 Define conversion functions                   |
| Closure in Ruby                  | The Power of Procs and Lambdas     | Implementing Lax                                  |
| Design Patterns in Ruby          | Composite                          |                                                   |
| Practical Object-Oriented Design | Sharing Role Behavior with Modules |                                                   |
| Eloquent Ruby                    | Embrace Dynamic Typing             | Shorter Programs, But Not                         |
| The Well Grounded Rubyist        | Functional                         | 16.2.1 Object#freeze and Object#frozen?           |
** Videos
|                     |      |     |
|---------------------+------+-----|
| Brett Codes - RSpec | ep 3 | 10m |
|                     |      |     |

** SLOC
| Project    | folder | file           | @ |
|------------+--------+----------------+---|
| ruby       | cgi    | cookie.rb      |   |
| sequel     |        |                |   |
| rbs        |        |                |   |
| solargraph |        | api_map.rb     |   |

* Base
** Objects
*** methods query
Returns a list of the names of public and protected methods of obj.
#+begin_src ruby
string = "aaa"
string.methods.grep(/case/).sort
#+end_src
*** initialize
#+begin_src ruby
class Point
  def initialize(x, y)
    @x = x
    @y = y
  end
end

Meh.new('foo', 'bar') #  #<Meh:0x0000000003a33d80 @x="bar", @y="foo">

#+end_src

Default/Optional arguments

#+begin_src ruby

class Meh
  def initialize(x='bar', y='foo')
    @x = x
    @y = y
  end
end

Meh.new # #<Meh:0x0000000003a33d80 @x="bar", @y="foo">
#+end_src
*** attributes
attr_accessor

attr_writer

attr_reader

#+begin_src ruby
attr_reader :name, :method_names, :lvar_names, :ivar_names, :cvar_names
#+end_src

*** private_methods / protected_methods
private and protected method names

#+begin_src ruby
Object.new.private_methods # 77
Object.new.protected_methods # 0
#+end_src
*** instance variables
*** freeze
- make objects (nearly) immutable

**** Add the following line to the top of any individual file:
# frozen_string_literal: true

**** Run your programs on the command line with a specific instruction.
This will make every string in your program frozen by default:

$ ruby --enable-frozen-string-literal my_program.rb

#+begin_src ruby
   person1.freeze # prevent modifications to the object
#+end_src
*** object_id
- Returns an integer identifier for obj.
- The same number will be returned on all calls to object_id for a given object, and no two active objects will share an id.

*** self
   - is a keyword
   - It does this to allow the method chaining in the line scores << 10 << 20 << 40 . Because each call to << returns the scores object, you can then call << again, passing in a new score.

     #+begin_src ruby

     class tea
       def self.drink () # Class-Level method (static)
	 puts 'drinking'
       end

       def meh
	 puts self # refers to tea class
       end

       def builder

	 self # return class
       end
     end
     #+end_src
*** methods
   default values, splat args (described later on page 120), keyword args, and a block parameter
#+begin_src ruby
def splating(*rest)
  puts rest.each { |x| puts }
end

def split_apart(first, *, last) # get first and last args, ignore middle ones
end

#+end_src
**** capture methods
#+begin_src ruby

class C
  def talk
    puts "Method-grabbing test!"
  end
end

c = C.new

meth = c.method(:talk)
meth.owner
meth.call # to exeute
meth[]
meth.()
#+end_src
**** unbind methods
unbind the method from its object and then bind it to another object, as long as
that other object is of the same class as the original object
#+begin_src ruby
class D < C
end

d = D.new
unbound = meth.unbind
unbound.bind(d).call
#+end_src

*** dup
   #+begin_src ruby
   person1 = "Tim"
   person2 = person1.dup # not aliasing person1
   #+end_src
*** ancestor
An array of ancestors—essentially, the method-lookup path for instances of this class.
*** statement modifiers
   if and unless Modifiers
   #+begin_src ruby
   puts "a = #{a}" if $DEBUG
   print total unless total.zero?
   a *= 2 while a < 100
   a -= 10 until a < 10
   #+end_src
** Classes
- :: is Ruby’s namespace resolution operator.
- Math::PI - access Math PI variable
- Math.sin(Math::PI/6.0) - access Math sin method
- Names of classes and modules are just constants.
- can nest classes and modules inside other classes and modules to any depth

*private*

#+begin_src ruby

class InvoiceWriter
  def initialize(order)
    @order = order
  end

  def write_on(output)
    write_header_on(output)
    write_body_on(output)
    write_totals_on(output)
  end

  private

  def write_header_on(output)
    # ...
  end

  def write_body_on(output)
    # ...
  end

  def write_totals_on(output)
    # ...
  end
end
#+end_src

*** Class methods
- Class methods are singleton methods defined on objects of class `Class`.
- a method defined as a singleton method of a class object can 2also be called on subclasses of that class.

#+begin_src ruby
class C
end

def C.a_class_method
  puts "Singleton method defined on C"
end

C.a_class_method # Singleton method defined on C
#+end_src

*method_defined?*

#+begin_src ruby
Post.method_defined?(:some_instance_method) #=> false
@post.method_defined?(:some_instance_method) #=> true
#+end_src

*respond_to?*

#+begin_src ruby
Post.respond_to?(:item_name) #=> false
@post.respond_to?(:item_name) #=> true
#+end_src

*** include
The include directive includes all methods from the given module and make them
available as instance methods in your class

#+begin_src ruby
module Greeting
  def hello
    puts 'Hello from module'
  end
end

class MyClass
  include Greeting
end

my_class = MyClass.new
my_class.hello # => 'Hello from module'

MyClass.ancestors # [MyClass, Greeting, Object, Kernel, BasicObject]

#+end_src

*** prepend
- The extend directive includes all methods from the given module and make them
  available as class methods in your class
#+begin_src ruby
module Greeting
  def hello
    puts 'Hello from module'
  end
end

class MyClass
  extend Greeting
end

MyClass.hello # => 'Hello from module'

MyClass.singleton_class.ancestors # [#<Class:MyClass>, Greeting, #<Class:Object>, #<Class:BasicObject>, Class, Module, Object, Kernel, BasicObject
#+end_src
*** extend
- the module is placed right after your class, but when you use prepend is
  prepended, which means that it is set before your class:
#+begin_src ruby
module Greeting
  def hello
    puts "Hello from module"
    super
  end
end

class MyClass
  prepend Greeting

  def hello
    puts "Hello from class"
  end
end

MyClass.new.hello
# => "Hello from module"
# => "Hello from class"

MyClass.ancestors # => [Greeting, MyClass, Object, Kernel, BasicObject]


#+end_src
*** superclass
#+begin_src ruby
class Parent
end
Parent.superclass # => Object
#+end_src

*** super
   #+begin_src ruby
   def x(y,z)
     super # passes all the parameters from the current method and hands the parameters to the method from the base class
     super() # calls the method without any arguments.
   end
   #+end_src
*** Singleton Classes
- Sometimes called meta-classes
- The Ruby standard library includes an implementation of the singleton pattern *require 'singleton'*
**** Methods
***** #singleton_class
Refers directly to the singleton class of an object
#+begin_src ruby
string = "a string"
string.singleton_class.ancestors # => [#<Class:#<String:0x0000563fb8797270>>, String, Comparable, Object,Kernel, BasicObject]
#+end_src
**** Singleton methods
*** usage
#+begin_src ruby
# frozen_string_literal: true

[].methods.grep /^re/ # finds methods begins with re

    require 'pathname'

    # Class Description
    class Meh # Class name in Camel Case
      OUCH = 'asdasd' # 1
      attr_reader :lo, :fi # 2

      # static method
      def self.from_file(file_name) # 3
	new(File.readlines(file_name))
      end

      def initialize(lo, fi) # 4
	@alpha = OUCH
	@lo = lo #
	@fi = fi #
      end

      private_class_method :new

      private

      def alfa # instance method
	@localVar = 1
      end

      def use_local_var # instance method
	@localVar
      end

      def self.zeta #
      end
    end

    Eija = Class.new #

    def Eija.beta # singleton
    end


    # superclass

    class Parent
    end
    class Child < Parent
    end

    Child.superclass # => Parent

    #
    meth.owner
    #
#+end_src

** Modules
- provide a namespace and prevent name clashes.
- support the mixin facility.
- can’t have instances,
- can include a module within a class definition.


   #+begin_src ruby

   module A
     module_function

     def foo
     end
   end

   module A
     module SubA
       def bar
       end
     end
   end


   A::foo
   A::SubA:bar

   a = Module.new

   a.class_eval do
     remove_method
     method_defined?

     attr_reader name
     alias_method x,e
   end

   #+end_src

*** Mixin
- adds functionality to classes
** Methods
- ?, !, and = are the only characters allowed as method name suffixes.
- parentheses around a method’s arguments are optional
- can omit the parentheses around the argument list
- can return a value
- may omit the return if it isn’t needed

*Required arguments*

#+begin_src ruby
def my_new_method(arg1, arg2, arg3)
  # Code for the method would go here
end

def my_other_new_method
  # Code for the method would go here
end
#+end_src

*Default arguments*

#+begin_src ruby
def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")
  "#{arg1}, #{arg2}, #{arg3}."
end

def surround(word, pad_width=word.length/2)
  "[" * pad_width + word + "]" * pad_width
end

surround("elephant") # => "[[[[elephant]]]]"
#+end_src

*Variable-Length Argument Lists*
- splatting an argument

#+begin_src ruby
def varargs(arg1, *rest)
  "arg1=#{arg1}. rest=#{rest.inspect}"
end
varargs('one') # => arg1=one. rest = []
varargs('one', 'two') # => arg1=one. rest = ['two']
varargs 'one', 'two', 'three' # => arg1=one. rest = %w[two three]

def split_apart(first, *splat, last)
  puts "First: #{first.inspect}, splat: #{splat.inspect}, " +
       "last: #{last.inspect}"
end
#+end_src

*Block associated*
- last parameter prefixed with an ampersand, any associated block is converted to a Proc object.

#+begin_src ruby
class TaxCalculator
  def initialize(name, &block)
    @name = name
    @block = block
  end

  def get_tax(amount)
    "#{@name} on #{amount} = #{@block.call(amount)}"
  end
end

tc = TaxCalculator.new('Sales tax') { |amt| amt * 0.075 }
tc.get_tax(100) # => "Sales tax on 100 = 7.5"
tc.get_tax(250) # => "Sales tax on 250 = 18.75"
#+end_src

#+begin_src ruby
def double(p1)
  yield(p1 * 2)
end

double(3) { |val| "I got #{val}" } # => "I got 6"
double('tom') { |val| "Then I got #{val}" } # => "Then I got tomtom"
#+end_src

*Optional arguments*

#+begin_src ruby
def forevis(*meh)
  meh.each { |x|  p x }
end
#+end_src

*Takes no keywords*

#+begin_src ruby
def x(**nil)
end
#+end_src

*Argument forwarding*
- ruby 3

#+begin_src ruby
def x(...)
end
#+end_src

*do end as param*

#+begin_src ruby
x = (do  1 + 2 end)
x = (do 'a' + 'b' end).join(',')
#+end_src

*Block as argument*

#+begin_src ruby
def cevadis(meh, &block)
  block.call
end
#+end_src

*name=*

#+begin_src ruby
def leite=()
end
#+end_src

*return*

#+begin_src ruby
def meth_three
100.times do |num|
square = num*num
return num, square if square > 1000
end
end
meth_three # => [32, 1024]
#+end_src

*keyword argument list*

#+begin_src ruby
def search(field, genre: nil, duration: 120)
  p [field, genre, duration ]
end

search(:title) # [:title, nil, 120]
search(:title, duration: 432) # [:title, nil, 432]
search(:title, duration: 432, genre: "jazz")  # [:title, "jazz", 432]

def search(field, genre: nil, duration: 120, **rest)
  p [field, genre, duration, rest ]
end
#+end_src

*Methods chaining*
creates a new object at it chains

#+begin_src ruby
puts animals.select {¦n¦ n[0] < 'M' }.map(&:upcase).join(", ")
#+end_src

** Types
*** Array
- index collection

#+begin_src ruby
a = [ 3.14159, "pie", 99 ]
a.class # => Array
#+end_src

*length*

*sub-index*

#+begin_src ruby
a = [ 1, 3, 5, 7, 9 ]
a[1, 3] # => [3, 5, 7]
a[3, 1] # => [7]
a[-3, 2] # => [5, 7]
#+end_src

*ranging*

- two-period form includes the end position

#+begin_src ruby
a = [ 1, 3, 5, 7, 9 ]
a[1..3]
# => [3, 5, 7]
a[1...3] # => [3, 5]
a[3..3]
# => [7]
a[-3..-1] # => [5, 7, 9]
#+end_src

*intersection (&)*

#+begin_src ruby
[1, 2, 3].intersection([2, 3, 4])
# [2, 3]

[1, 2, 3] & [2, 3, 4]
# [2, 3]
#+end_src

union (|)

difference (-)

queue

#+begin_src ruby
queue = []

queue.unshift "apple"
queue.unshift "orange"
queue.unshift "banana"

# ["banana", "orange", "apple]"

queue.pop
# "apple"

queue.pop
# "orange"
#+end_src


new
#+begin_src ruby

Array.new(4) # [nil, nil, nil, nil]
Array.new(4) { |x| x + 1 } # [1, 2, 3, 4]

#+end_src

Kernel#Array
- More forgiving than .to_a

#+begin_src ruby
Array 1 # [1]
#+end_src

push
pop
access
find
delete
max_by
compact
new
#+begin_src ruby
a = Array.new
# shallow copy
b = Array.new [1,2,3]
#+end_src
reverse_each
each_index

*More Examples*

#+begin_src ruby
array = [ 1, 2, 3, 4, 5, 6, 7 ]
array.first(4) # => [1, 2, 3, 4]
array.last(4) # => [4, 5, 6, 7]
#+end_src

   #+begin_src ruby
   h = { a: 100, b: 20 }
   h.delete_if { |key, value| value < 25 }
   h.delete(:a)
   #+end_src

   #+begin_src ruby
   # creation
   a = [1, ["a", "b"], 4]
   a = Array.new(1,2)
   a = arr = %w( Hey!\tIt is now -#{Time.now}- )


   # indexing
   arr[1][0]
   [1,2][0]
   arr.dig(3,0) value_at, a[2,3] = ..
				   a[2..3]
   a.slice()
   a.[]=(0, "first")
   a.[](2)
   a = %w(a b c)
   a= %W({a} b c)
   x.to_ary
   x.to_arr
   Array()
   def string.to_arr
   end
   a.unshift(0)
   a.push(1,2,3)
   a << 5
   a.pop
   a.shift
   a.concat
   a.replace([1,2,3])
   a.flatten
   a.reverse
   a.join(" , ")
   a = *
       a.uniq
   a.compact
   a.size
   a.empty
   a.include?
   a.first
   a.first[<num>]
   a.last
   a.sample # return
   a.count(1)
   #+end_src
   [[file:path]]
*** Boolean
- any value that is not nil or the constant false is true
- nil is false
- The number zero is not interpreted as a false value. Neither is a zero-length string.

*** String
- dealing with text or data
- objects of class String

#+begin_src ruby
'escape using "\\"' # => escape using "\"
'That\'s right' # => That's right
#+end_src

#+begin_src ruby
puts
"now is #{ def the(a)
'the ' + a
end
the('time')
} for all bad coders..."
#+end_src

#+begin_src ruby
%q/general single-quoted string/ # => general single-quoted string
%Q!general double-quoted string! # => general double-quoted string
%Q{Seconds/day: #{24*60*60}} # => Seconds/day: 86400

# even simpler

%!general double-quoted string! # => general double-quoted string
%{Seconds/day: #{24*60*60}} # => Seconds/day: 86400
#+end_src


*Interpolation*

#+begin_src ruby
age  = 33
name = "Jesus"

"Hello, my name is #{name} & I'm #{age} years old."
#+end_src

*HERE documents*

#+begin_src ruby
<<EOL # double quote document
   \n
#{Time.now}
EOL

<<EOL.to_i * 10
EOL

<<'EOL' # single quote document
   \n
#{Time.now}
EOL

<<~EOL
EOL

[1,2, <<EO asdasd EO]

a(false, <<EO asd... EO)
#+end_src

*<<-  minus sign*

- can be indented from the margin.

#+begin_src ruby
<<-EOL
Concat
        STRING1
    enate
EOL

#+end_src

*Quoting*

   %char{text}
   #+begin_src ruby
   a = %q(a b c d)

   b = %Q(a b c)
   #+end_src

*Encondig*

#+begin_src ruby
#encoding: utf-8
#+end_src

#+begin_src ruby
plain_string = "dog"
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}" # Encoding of "dog" is UTF-8
utf_string = "δog"
puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}" # Encoding of "δog" is UTF-8
#+end_src

*Character Constants*

- deprecated

#+begin_src ruby
?a
?\n
?\C-a
?\M-a
?\M-\C-a
?\C-?
# => "a"
(printable character)
# => "\n"
(code for a newline (0x0a))
# => "\u0001" (control a)
# => "\xE1" (meta sets bit 7)
# => "\x81" (meta and control a)
# => "\u007F" (delete character)
#+end_src

*More examples*

#+begin_src ruby
"Test" + "Test" #TestTest
"test".capitalize #Test
"Test".downcase #test
"Test".chop #Tes
"Test".next #Tesu
"Test".reverse #tseT
"Test".sum #416
"Test".swapcase #tEST
"Test".upcase #TEST
"Test".upcase.reverse #TSET
"Test".upcase.reverse.next
"Test".ord
"Test".chr
"xyz".scan(/./) { |letter| puts letter }

# SUBSTITUTION

"".sub('i', '') # only does one substitution at a time, on the first instance of the text to match
"".gsub('i', '') #  whereas gsub does multiple substitutions at once
#+end_src




new

#+begin_src ruby
String.new("an unfrozen string")
#+end_src

*concat*

#+begin_src ruby
str = ""

str.concat("a")
str.concat("a")

str
# "aa"
#+end_src

*dup*

*freeze/ unfreezen*

#+begin_src ruby
str = "frozen!"
str.frozen? # true

unfrozen_str = +str
unfrozen_str.frozen? # false
#+end_src

*each_byte*

*scan*
#+begin_src ruby
s = 'Peter Piper picked a peck of pickled peppers'
s.scan(/[Pp]\w*/) {|word| puts("The word is #{word}")}
#+end_src
*** Symbols
- undeclared constant names guaranteed to be unique.
- an identifier in your code,
#+begin_src ruby
:Object
:my_variable
:"Ruby rules"
a = "cat"
:'catsup' # => :catsup
:"#{a}sup" # => :catsup
:'#{a}sup' # => :"\#{a}sup"
#+end_src
*** Numbers
- can be any length
- objects of class Fixnum and Bignum
- 0 for octal, 0d for decimal, 0x for hex, or 0b for binary
- includes support for rational and complex numbers
- all numbers are objects

#+begin_src ruby
num = 10001
4.times do
puts "#{num.class}: #{num}"
num *= num
end
produces:

Fixnum: 10001
Fixnum: 100020001
Fixnum: 10004000600040001
Bignum: 100080028005600700056002800080001
#+end_src

#+begin_src ruby
123456
0d123456
123_456
-543
0xaabb
0377
-0b10_1010
123_456_789_123_456_789
#+end_src

#+begin_src ruby
3.times
{ print "X " }
1.upto(5)
{|i| print i, " " }
99.downto(95) {|i| print i, " " }
50.step(80, 5) {|i| print i, " " }
10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
#+end_src

*Rational*
- Rationals are slower than floats, but since they are exact numbers,
- use a rational whenever you need to do calculations with non-integer values and you need exact answers.

#+begin_src ruby
Rational(2,3)
1.1r
#+end_src

*Complex*

#+begin_src ruby
Complex(1,2)
#+end_src
*** Range
|     |                                      |
|-----+--------------------------------------|
| ..  | inclusive                            |
| ... | exclusive, excludes its last element |

#+begin_src ruby
# create a new range object
r = 1..2

# include all elements
r =  1..99

# exclude last element
r = 1...199

# range of object need to return the next object `succ` and be comparable <=>

# ranges as conditions
while line = gets
  puts line if line =~ /start/ .. line =~ /end/
end

r.cover? 2
r.include? 3
r.max
r.reject {}

('a'..'m').inject :+ # => "abcdefghijklm"

(1..10).to_a # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
('bar'..'bat').to_a # => ["bar", "bas", "bat"]
#+end_src

*as intervals*
#+begin_src ruby
(1..10) === 5   # => true
(1..10) === 15  # => false

car_age = gets.to_f
# let's assume it's 9.5
case car_age
when 0...1
  puts "Mmm.. new car smell"
when 1...3
  puts "Nice and new"
when 3...10
  puts "Reliable but slightly dinged"
when 10...30
  puts "Clunker"
else
  puts "Vintage gem"
end

# produces:
  Reliable but slightly dinged

#+end_src



*new*

#+begin_src ruby
r = Range.new(1,100)
r = Range.new(1,100, true)
#+end_src

*to_enum*

#+begin_src ruby
enum = ('bar'..'bat').to_enum
enum.next # => "bar"
enum.next # => "bas"
#+end_src

*methods*

#+begin_src ruby
class PowerOfTwo
  attr_reader :value

  def initialize(value)
    @value = value
  end

  def <=>(other)
    @value <=> other.value
  end

  def succ
    PowerOfTwo.new(@value + @value)
  end

  def to_s
    @value.to_s
  end
end
p1 = PowerOfTwo.new(4)
p2 = PowerOfTwo.new(32)
puts (p1..p2).to_a
4
8
16
32
#+end_src

*endless range*

#+begin_src ruby
["a", "b", "c"].zip(1..)
# [["a", 1], ["b", 2], ["c", 3]]

[1,2,3,4,5][1..]
# [2, 3, 4, 5]

(1..).step(5).take(100)
# [1, 6, 11, 16, 21, 26, 31, 36, 41, 46]
#+end_src

*ArithmethicSequence*

#+begin_src ruby
(1..10).step(2) == (1..10).step(2)
# false - Ruby 2.5 (and older)

(1..10).step(2) == (1..10).step(2)
# true - Ruby 2.6
#+end_src

*%*

#+begin_src ruby
((0..) % 2).take(5)

# [0, 2, 4, 6, 8]
#+end_src
*** Sized Queue
- push (same as <<) operation will suspend the current thread until an item is taken off the queue.
- same as a regular queue but with a size limit.
- raise an exception instead, passing true as an argument to push

#+begin_src ruby
que = SizedQueue.new(5)
que.push(:bacon)
que.push(:bacon, true) # raises ThreadError: queue full
#+end_src
*** Sets
   #+begin_src ruby
   s = Set.new(array)
   s = Set.new(names) {name name.upcase }
   s << 5
   s.add 5
   s.delete(1)
   s.intersection|&| x
   s.union x
   s + x
   s.difference x
   s - x
   s ^ x
   s.merge [2]
   s.subset? b
   s.superset? b
   s.proper_subset? x
   s.proper_superset? x
   #+end_src
*** Hash
- keys must be comparable
- rehash force the hash to be reindexed whenever a key has changed
- remains in initial order
- index collection

store
acess
delete

has_key?

#+begin_src ruby
if counts.has_key?(next_word)
counts[next_word] += 1
else
counts[next_word] = 1
end
#+end_src

each_key
each_value
find(<value>)

#+begin_src ruby
# Strings keys
h = { "one" => 1, "two" => 2 }

# Symbols keys
h = { one: 1, two: 2 }

# Empty Hash
h = Hash.new

# default value is zero
h = Hash.new(0)

# Hash alternative(old) version
h = Hash[1, "one", 2, "two"]


# get value
h["one"] = 1
h[:one]

h.rehash # force the hash to be reindexed

h.[]=("New York", "NY")
h.store("New York", "NY")
a.update(b)
h.select {k,vk > 1 } !
h.reject {  k,v  k > 1 } !
h.reject! {  k,v  k > 1 }
h = { street: "127th Street", apt: nil }.compact!
h = { street: "127th Street", apt: nil }.compact!
h.invert
h.clear
h = {...}.replace({...})
h.key?
h.empty?
#+end_src

*merge*

#+begin_src ruby
a.merge(b)
a = { a: 1 }
b = { b: 2 }
c = { c: 3 }

a.merge(b).merge(c)
# {:a=>1, :b=>2, :c=>3}

# ruby 2.6
a.merge(b, c)
# {:a=>1, :b=>2, :c=>3}
#+end_src
*** nil

- a signal that a method that modifies the receiver did not make a modification

NilClass

*** Queue
- thread-safe, blocking.
- If the queue is empty, calling pop will put your current thread to sleep &
  wait until something is added to the queue.
- passing true to avoid blocking


#+begin_src ruby
que = Queue.new

que << 1
que << 2
que << 3

que.pop # 1
que.pop # 2

que.pop(true)
#+end_src
** Expression

*<<*

#+begin_src ruby

class ScoreKeeper
  def initialize
    @total_score = @count = 0
  end

  def <<(score)
    @total_score += score
    @count += 1
    self
  end

  def average
    raise 'No scores' if @count.zero?

    Float(@total_score) / @count
  end
end
#+end_src

*[]*

#+begin_src ruby
class SomeClass
  def [](p1, p2, p3)
    # ...
  end

  def []=(*params)
    value = params.pop
    puts "Indexed with #{params.join(', ')}"
    puts "value = #{value.inspect}"
  end
end

s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
#+end_src

*and &&*
- _and_ binds lower than _&&_

#+begin_src ruby
nil
&& 99 # => nil
false && 99 # => false
"cat" && 99 # => 99
#+end_src

*or ||*


#+begin_src ruby
nil
|| 99 # => 99
false || 99 # => 99
"cat" || 99 # => "cat"
#+end_src

*not !*
- not and ! differ only in precedence.

*defined?*
- returns nil
- If the argument is yield, defined? returns the string “yield” if a code block is associated with the current context.

#+begin_src ruby
defined? 1 # => "expression"
defined? dummy # => nil
defined? printf # => "method"
defined? String # => "constant"
defined? $_ # => "global-variable"
defined? Math::PI # => "constant"
defined? a = 1 # => "assignment"
defined? 42.abs # => "method"
defined? nil # => "nil"
#+end_src

*if*
- can have zero or more elsif clauses
- can have an optional else clause.
- then keyword is optional

#+begin_src ruby
if artist == "Gillespie" then
  handle = "Dizzy"
elsif artist == "Parker" then
  handle = "Bird"
else
  handle = "unknown"
end

if artist == "Gillespie"
  handle = "Dizzy"
elsif artist == "Parker"
  handle = "Bird"
else
  handle = "unknown"
end
#+end_src

#+begin_src ruby
handle = if artist == 'Gillespie'
           'Dizzy'
         elsif artist == 'Parker'
           'Bird'
         else
           'unknown'
         end
#+end_src

#+begin_src ruby
mon, day, year = $1, $2, $3 if date =~ /(\d\d)-(\d\d)-(\d\d)/
puts "a = #{a}" if $DEBUG
#+end_src

*unless*

#+begin_src ruby
unless duration > 180
  listen_intently
end
#+end_src

#+begin_src ruby
print total unless total.zero?

File.foreach('/etc/passwd') do |line|
  next if line =~ /^#/ # Skip comments

  parse(line) unless line =~ /^$/   # Don't parse empty lines
end

#+end_src

*Ternary*

#+begin_src ruby
cost = duration > 180 ? 0.35 : 0.25
#+end_src

*case*

- first true case

#+begin_src ruby
case
when song.name == "Misty"
  puts "Not again!"
when song.duration > 120
  puts "Too long!"
when Time.now.hour > 21
  puts "It's too late"
else
  song.play
end
#+end_src

- pattern match

#+begin_src ruby
case command
when "debug"
  dump_debug_info
  dump_symbols
when /p\s+(\w+)/
  dump_variable($1)
when "quit", "exit"
  exit
else
  print "Illegal command: #{command}"
end
#+end_src

- comparison === target.

#+begin_src ruby
kind = case year
       when 1850..1889 then "Blues"
       when 1890..1909 then "Ragtime"
       when 1910..1929 then "New Orleans Jazz"
       when 1930..1939 then "Swing"
       else
         "Jazz"
       end
#+end_src
- comparing objects

#+begin_src ruby
case shape
when Square, Rectangle
# ...
when Circle
# ...
when Triangle
# ...
else
# ...
end
#+end_src

*while*
   # WHILE , UNTIL , and FOR loops are built into the language and do not introduce new scope;
#+begin_src ruby
while line = gets
  # ...
end

a = 1
a *= 2 while a < 100
a # => 128

file = File.open("ordinal")
while line = file.gets
  puts(line) if line =~ /third/ .. line =~ /fifth/
end

print "Hello\n" while false
begin
  print "Goodbye\n"
end while false
#+end_src

*until*

#+begin_src ruby
until play_list.duration > 60
  play_list.add(song_list.pop)
end

a -= 10 until a < 100
a # => 98
#+end_src

#+begin_src ruby
# when an enumerator object runs out of values inside a loop , the loop will terminate cleanly.
# newly local variables created in LOOP are not accessible outside the block
loop do
  puts "#{short_enum.next} - #{long_enum.next}"
end

# not a ruby way, translated by ruby to x.each
for song in playlist
  song.play
end


# NEXT skips to the end of the loop, effectively starting the next iteration
# BREAKn

i=0
loop do
  i += 1
  next if i < 3
  print i
  break if i > 4 # If a conventional loop doesn’t execute a break , its value is nil .
end

# REDO repeats the current iteration of the loop from the start but without reevaluating
# the condition or fetching the next element (in an iterator)
while line = gets
  next if line =~ /^\s*#/   # skip comments
  break if line =~ /^END/   # stop at end

  # substitute stuff in backticks and try again
  redo if line.gsub!(/`(.*?)`/) { eval($1) }

  # process line ...
end
#+end_src

*times*

#+begin_src ruby
3.times do
  print "Ho! "
end
#+end_src

*upto*

#+begin_src ruby
0.upto(9) do |x|
  print x, " "
end # 0 1 2 3 4 5 6 7 8 9

0.step(12, 3) {|x| print x, " " } #0 3 6 9 12

[ 1, 1, 2, 3, 5 ].each {|val| print val, " " } # 1 1 2 3 5
#+end_src

*for ... in*

#+begin_src ruby
for song in playlist
  song.play
end

for i in %w[fee fi fo fum]
  print i, ' '
end
for i in 1..3
  print i, ' '
end
for i in File.open('ordinal').find_all { |line| line =~ /d$/ }
  print i.chomp, ' '
end
#+end_src

#+begin_src ruby
class Periods
  def each
    yield 'Classical'
    yield 'Jazz'
    yield 'Rock'
  end
end
periods = Periods.new
for genre in periods
  print genre, ' '
end
#+end_src

*break*
#+begin_src ruby
i = 0
loop do
  i += 1
  next if i < 3

  print i
  break if i > 4
end

result = while line = gets
           break(line) if line =~ /answer/
         end
#+end_src

*redo*

Repeats the current iteration of the loop from the start but without reevaluating
the condition or fetching the next element (in an iterator)

*next*

Skips to the end of the loop,effectively starting the next iteration

#+begin_src ruby
while line = gets
  next if line =~ /^\s*#/
  break if line =~ /^END/

  # skip comments
  # stop at end
  # substitute stuff in backticks and try again
  redo if line.gsub!(/`(.*?)`/) { eval(Regexp.last_match(1)) }
  # process line ...
end
#+end_src

** Enumerable
concepts

immutability

method chaining

#+begin_src ruby
"joe".upcase.reverse # "EOJ"
#+end_src

*map*

- returns array
- non-destructive

#+begin_src ruby
a.map { |x| x.uppercase}
#+end_src

*map!*

- destructive

#+begin_src ruby
a.map! { |x| x.uppercase}
#+end_src

*flat_map*

#+begin_src ruby
[["1","2"],["3","4"]].flat_map {|i| i[0] }     # => ["1", "3"]
[["1","2"],["3","4"]].flatten.map {|i| i[0] }  # => ["1", "2", "3", "4"]
#+end_src

** Functional
*proc*

- if the last parameter in a method definition is prefixed with an ampersand,
  any associated block is converted to a Proc object, and that object is
  assigned to the parameter. This allows you to store the block for use later.

#+begin_src ruby
p = Proc.new { puts "yay" }
p = proc { puts "yay" }
p.call

def x(&block)
  block.call
end

x(&p) # => yay
x(p.to_proc) # => yay

y = Proc.new {|y| puts y.upcase }
%w{ David Black }.each(&y) # => DAVID BLACK

class Symbol
  def to_proc
    puts "In the new Symbol#to_proc!"
    Proc.new {|obj| obj.public_send(self) }
  end
end

def multiply_by(m)
  Proc.new {|x| puts x * m }
end
mult = multiply_by(10)
mult.call(12

   def pass_in_block(asdf, &block)
   end

   multiple_of_three = -> n { (n % 3).zero? }
   palindrome = -> n { n = n.to_s; n == n.reverse }

   p Integer
       .all
       .select(&multiple_of_three)
       .select(&palindrome)
       .first(10)

   a = Proc.new

   def initialize(name, &block) # initialize can receive proc object

     tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
     tc.get_tax(100) # => "Sales tax on 100 = 7.5"

#+end_src

*lambda*

    #+begin_src ruby
    lambda { |params| ... } # form 1

    -> params { ... }  # form 2
    #+end_src

usage

#+begin_src ruby
proc1 = -> arg { puts "In proc1 with #{arg}" }
proc1.call "ant"

def n_times(thing)
  lambda {|n| thing * n }
end

p1 = n_times(23)
p1.call(3) # => 69
#+end_src


 #+begin_src ruby
 l = -> { xx; aa }
 l = lambda do
   yield xx
 end
 #+end_src

sugar syntax:
- dot operator as shortcut. note: better avoid this one
- square brackets too

#+begin_src ruby

l = -> (x) { p x }
l.('meh')
l['meh']

#+end_src

*curry*

Returns a curried proc based on the method. When the proc is called with a
number of arguments that is lower than the method’s arity, then another curried
proc is returned. Only when enough arguments have been supplied to satisfy the
method signature, will the method actually be called.

The optional arity argument should be supplied when currying methods with
variable arguments to determine how many arguments are needed before the method
is called.

#+begin_src ruby
#+end_src

Optional arity argument

When called with this argument, the curried object will only be evaluated when
the given number of arguments has been supplied:

#+begin_src ruby

sum_all = -> (*nums) { nums.reduce(:+) }
sum_all.curry.(1,2,3) # 6
sum_at_least_four = sum_all.curry(4)
sum1 = sum_at_least_four.(3,4) # #<Proc:0x000055d2f90867a0 (lambda)>
sum2 = sum1.(5) # #<Proc:0x000055d2f90b4948 (lambda)>
sum3 = sum2.(7) # 19

#+end_src

Currying methods

#+begin_src ruby

def add(a, b, c) ; a + b + c ; end # :add

fun = method(:add).curry # #<Proc:0x000055f71cb45758 (lambda)>
fun.(1,2,3) # 6

#+end_src

** Logs
*** Logger
- 1st parameter is where to save log messages
- 2nd parameter is how many log files you want to keep (log rotation)
- the last parameter is the maximum file size.
- levels: DEBUG INFO WARN ERROR FATAL UNKNOWN
- different levels helps you filter your log file

#+begin_src ruby
Logger.new(<file>, <how many log files>, <maximum file size>)
#+end_src


#+begin_src ruby
logger = Logger.new("my_log")

logger = Logger.new(STDOUT) #  display messages on the terminal

logger.info("I'm reading a RubyGuide about logging!")

logger.formatter = proc { |severity, datetime, progname, msg| "#{severity}, #{datetime}, #{msg}\n" } # DEBUG, 2019-08-08 19:39:01 +0200, testing
#+end_src
** Kernel
*** alias
#+begin_src ruby
class String
  alias __old_reverse__ reverse
end

class String
  alias_method :__old_reverse__, :reverse
end

#+end_src
*** autoload
#+begin_src ruby
autoload :SharedContext, 'rspec/core/shared_context'
#+end_src
*** grep

** Pattern Matching
#+begin_src ruby
[1,2,3] in [a,b,c] # true
[1,2,3] in [a]     # false

{ a: 1, b: 2, c: [] } in { a: a, b: b, c: [] } # true
p a # 1
#+end_src
** Project structure
   #+begin_src ruby
   anagram/    <- top-level
   bin/      <- command-line interface goes here
   lib/      <- three library files go here
   test/     <- test files go here
   #+end_src
** Errors
*** Exceptions
- class *Exception*
- Custom exceptions subclasses of StandardError or its children.
- has an associated message string and a stack backtrace.
- Custom exceptions can add extra information
- rescue matches thrown Exception and use it. Similar to case statement
- rescue clause with no parameter list, the parameter defaults to StandardError .
- rescue clause can be arbitrary expressions (including method calls) that return an Exception class.
**** Errors
    - StandardError
    -
**** usage
    #+begin_src ruby

    # Exception skeleton

    f = File.open("/a/file")
    begin
    # .....
    rescue Exception
      if @esmtp then
	@esmtp = false
	retry # repeat the entire begin / end block
      else
	raise # reraise the exception. FAIL is similar
      end
    else # after RESCUE and before any ENSURE, is executed only if no exceptions are raised by the main body of code.
      puts "Congratulations-- no errors!"
    ensure
      f.close
    end

    # At the end of each rescue clause, you can give Ruby the name
    # of a local variable to receive the matched exception.
    begin
      eval string
    rescue SyntaxError, NameError => boom
      print "String doesn't compile: " + boom
    rescue StandardError => bang
      print "Error running script: " + bang
    end

    # reraises the current exception (or a RuntimeError if there is no current exception).
    # This is used in exception handlers that intercept an exception before passing it on.
    raise

    # Creates a new RuntimeError exception, setting its message to the given string.
    raise "bad mp3 encoding" #

    # first argument to create an exception and then sets the associated
    # message to the second argument and the stack trace to the third argument.
    raise InterfaceException, "Keyboard failure", caller

    raise

    raise "Missing name" if name.nil?

    if i >= names.size
      raise IndexError, "#{i} >= size (#{names.size})"
    end

    raise ArgumentError, "Name too big", caller

    # removes two routines from the backtrace
    # by passing only a subset of the call stack to the new exception:
    raise ArgumentError, "Name too big", caller[1..-1]
    #+end_src
**** begin rescue
   #+begin_src ruby
   begin
     puts 'I am before the raise.'
     raise 'An error has occured.'
     puts 'I am after the raise.'
   rescue
     puts 'I am rescued.'
   end
   #+end_src
*** Trace
**** caller
The caller method provides an array of strings. Each string represents one step in the stack trace:
#+begin_src ruby
def x
  p caller
  end
#+end_src
*** System Errors
   - SystemCallError
   - subclasses are defined in a module called Errno
**** usage
    #+begin_src ruby
    Errno::EAGAIN
    Errno::EIO
    Errno::EPERM

    Errno::EAGAIN::Errno # => 35, same error number as EWOULDBLOCK, can be interchangeable
    Errno::EPERM::Errno # => 1
    Errno::EWOULDBLOCK::Errno # => 35
    #+end_src
** Parallel / Concurrency
*** Thread
- If the program ends while one or more threads are running, those threads are killed.
- can be asleep or awake, and alive or dead.

#+begin_src ruby
x = Thread.new { puts "What's the big deal" }
x.value
x.join
x.exit

Thread.kill(x)

threads = []
threads << Thread.new { puts "What's the big deal" }
threads << Thread.new { 3.times { puts "Threads are fun!" } }
threads.each { |thr| thr.join }


t = Thread.new do
  (0..2).each do |n|
    begin
      File.open("part0#{n}") do |f|
        text << f.readlines
      end
    rescue Errno::ENOENT
      puts "Message from
thread: Failed on n=#{n}"
      Thread.exit
    end
  end
end
t.join

Thread.stop
t.status
t.stop?
t.alive
t.wakeup
t.join
t.inspect

t.current[:message] = "Holla"

t.fetch(:message)
t.fetch(:msg, "ola")
#+end_src
*** Fibers
- no require
- resume
- yield
- require: requiring `fiber library` gives additional `transfer` methods
**** errors
    - FiberError: calling resume after last fiber returned `nil`
**** usage
#+begin_src ruby

twos = Fiber.new do
  num = 2
  loop do
	Fiber.yield(num) unless num % 3 == 0 # returning control to the calling context
	num += 2
  end
end

10.times { print twos.resume, " " }
#+end_src

   #+begin_src ruby
   f = Fiber.new do
     x = 0
     loop do
       Fiber.yield x
       x -= 1
     end
   end
   #+end_src
*** Mutex
** delimited input
   #+begin_src ruby
   # %q - Single-quoted string
   %q{\a and #{1+2} are literal}

   # %Q, % - Double-quoted string
   %Q{\a and #{1+2} are expanded}

   # %w, %W - Array of strings
   %w[ one two three ]

   # %i, %I -  Array of symbols
   %i[ one two three ]

   # %r - Regular expression pattern
   %r{cat|dog}

   # %s - A symbol
   %s!a symbol!

   # %x, `` - Shell command
   %x(df -h)

   #+end_src
** Variables

multiple assignment

#+begin_src ruby
@class_name, @receiver, @original_message = exception.name, exception.receiver, exception.original_message
#+end_src

*Delayed assignment ||=*

- no assignment is made at all if the variable is already set.

#+begin_src ruby
@corrections ||= SpellChecker.new(dictionary: class_names)
#+end_src

*class variables*

- available throughout a class or module body
- must be initialized before use
- is shared among all instances of a class and is available within the class itself.

#+begin_src ruby
class Meh
  @@foo = 'Bar'

  def value
    @@foo
  end
end
#+end_src

*instance variables*

#+begin_src ruby
class Meh
  @foo = 'Bar'

  def to_s
    @foo
  end
end
#+end_src

*Global variables*

- available throughout a program.
- references to it returns the same object.
- referencing an uninitialized global variable returns nil.
- $SAFE —set to 0 by default. Setting $SAFE
  to 1 will prevent Ruby from running potentially unsafe methods like eval on
  tainted data by raising a SecurityError .

#+begin_src ruby
$? # return global status of last command
$SAFE
#+end_src

*constant*
- constants can change, but issues a warning message.

#+begin_src ruby
ADULT_AGE = 18
ABC = 1
Goo = 2
Foo = 3

class RubyBlog
  URL    = "rubyguides.com"
  AUTHOR = "Jesus Castello"
end

p RubyBlog::AUTHOR # "Jesus Castello"

#+end_src

::constants
::const_get
::const_set
::const_missing
::const_defined?
::remove_const
::private_constant

*private_constant*

#+begin_src ruby
 private_constant :ADULT_AGE
#+end_src

#+begin_src ruby
person1 = "Tim"
person2 = person1.dup
#+end_src

#+begin_src ruby
person1 = "Tim"
person1.freeze
#+end_src

*Parallel Assignment*

#+begin_src ruby
a, b = 1, 2 # a=1, b=2
a, b = b, a # b=2, a=1

a = 1, 2, 3, 4 # a=[1, 2, 3, 4]
b = [1, 2, 3, 4] # b=[1, 2, 3, 4]
a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5
#+end_src

*Excessive is discarded*

#+begin_src ruby
a, b = 1, 2, 3, 4 # a=1, b=2
c, = 1, 2, 3, 4 # c=1
#+end_src

*Splat just a few*

#+begin_src ruby
*a, b = 1, 2, 3, 4# a=[1, 2, 3], b=4
c, *d, e = 1, 2, 3, 4# c=1, d=[2, 3], e=4
f, *g, h, i, j = 1, 2, 3, 4# f=1, g=[], h=2, i=3, j=4
#+end_src

*Ignoring values*

#+begin_src ruby
first, *, last = 1,2,3,4,5,6 # first=1, last=6
#+end_src

*Nested Assignments*

#+begin_src ruby
a, (b, c), d = 1,2,3,4# a=1, b=2, c=nil, d=3
a, (b, c), d = [1,2,3,4]# a=1, b=2, c=nil, d=3
a, (b, c), d = 1,[2,3],4# a=1, b=2, c=3, d=4
a, (b, c), d = 1,[2,3,4],5# a=1, b=2, c=3, d=5
a, (b,*c), d = 1,[2,3,4],5# a=1, b=2, c=[3, 4], d=5
#+end_src

*block-local variables*

#+begin_src ruby
square = 'yes'
total = 0
[1, 2, 3].each do |val; square|
  square = val * val
  total += square
end
puts "Total = #{total}, square = #{square}"
#+end_src

** Comparison
*==*
Test for equal value.

#+begin_src ruby
class T
  def ==(other)
    puts "Comparing self == #{other}"
    other == 'value'
  end
end

t = T.new
p(t == "value")
p(t != "value")
#+end_src

*===*
Used to compare each of the items with the target in the when clause of a case
statement.

*<=>*
General comparison operator. Returns -1, 0, or +1, depending on whether its
receiver is less than, equal to, or greater than its argument.

*<, <=, >=, >*
Comparison operators for less than, less than or equal, greater than or equal,
and greater than.

*=~*
Regular expression pattern match.

*eql?*
True if the receiver and argument have both the same type and equal values.

*equal?*
True if the receiver and argument have the same object ID.

*!=*

#+begin_src ruby
class T
  def ==(other)
    puts "Comparing self == #{other}"
    other == 'value'
  end

  def !=(other)
    puts "Comparing self != #{other}"
    other != 'value'
  end
end
#+end_src


*!~*

#+begin_src ruby
#+end_src

** Conditional
   #+begin_src ruby
   '11' || 11
   '11' or 11 # same precedence
   var ||= "default value" # assign a value to a variable only if that variable isn’t already set


   '11' && 11 # higher precedence
   '11' and 11

   !true
   not true
   #+end_src
** Blocks
*block-local variables*

   #+begin_src ruby
   square = "yes"
   total = 0
   [ 1, 2, 3 ].each do |val; square|
     square = val * val
     total += square
   end
   puts "Total = #{total}, square = #{square}"
   produces:
     Total = 14, square = yes
   #+end_src

*numbered parameters*

#+begin_src ruby
[1,2,3].each { puts _1 }
#+end_src

*yield*

   #+begin_src ruby

   def foo
     yield
   end

   def bar
     if block_given?
       yield
     else
       'lol'
     end

     foo { p 'meh' }
     bar # => lol
     bar { p 'yahoo' } # => yahoo
   #+end_src

*yield_self*

refers to the object we’re calling the method on.

#+begin_src ruby
n_squared = ->(n) { n ** 2 }

2.yield_self(&n_squared) # 4
  .yield_self(&n_squared) # 16
#+end_src

as object

#+begin_src ruby
class ProcExample
def pass_in_block(&action)
@stored_proc = action
end
def use_proc(parameter)
@stored_proc.call(parameter)
end
end
#+end_src


#+begin_src ruby
def create_block_object(&block)
  block
end

bo = create_block_object { |param| puts "You called me with #{param}" }
bo.call 99
bo.call "cat"
#+end_src

As Closures

#+begin_src ruby
def n_times(thing)
  lambda {|n| thing * n }
end
p1 = n_times(23)
p1.call(3) # => 69
p1.call(4) # => 92
p2 = n_times("Hello ")
p2.call(3) # => "Hello Hello Hello "
#+end_src


#+begin_src ruby
proc1 = lambda do |a, *b, &block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc1.call(1, 2, 3, 4) { puts "in block1" }
#+end_src

#+begin_src ruby
proc2 = -> a, *b, &block do
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc2.call(1, 2, 3, 4) { puts "in block2" }
#+end_src

** Regular Expressions
- Regexp
#+begin_src ruby
# object form
Regexp.new

# literal form
/pattern/
%r{pattern}

#+end_src

** Operators
   #+begin_src ruby
   val.to_s =~ /3/
   #+end_src
** System calls
*** open3
opens communication with an external program and gives you handles on the
external program’s standard input, standard output, and standard error streams.

#+begin_src ruby
require 'open3'

#+end_src

*** open
- | pipe The pipe in front of the word cat indicates that we’re looking to talk to a program and not open a file.
#+begin_src ruby

d = open("|cat", "w+")
d.puts "Hello world"
d.gets
d.close


open("|cat", "w+") {|p| p.puts("hi"); p.gets }
#+end_src
** Date/Time
   #+begin_src ruby
   require 'date'
   d = date.today

   require 'time'
   t = time.zxcz
   #+end_src
** Lazy
   #+begin_src ruby
   (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
   #+end_src
** Eval
*** eval
#+begin_src ruby
eval("puts 'x'")
eval("puts 'x'", b) # b for binding
#+end_src
*** instance_eval
    - class methods
*** Binding
#+begin_src ruby
def use_a_binding(b)
  eval("puts str", b)
end
str = "I'm a string in top-level binding!"
use_a_binding(binding)
#+end_src
*** instance_exec
- take arguments. Any arguments you pass it will be passed, in turn, to the code block.
#+begin_src ruby
string = "A sample string"
string.instance_exec("s") {|delim| self.split(delim) }
#+end_src
*** class_eval
- instance methods
#+begin_src ruby
c = Class.new
c.class_eval do
  def some_method
    puts "Created in class_eval"
  end
end

c_instance = c.new
c_instance.some_method
#+end_src
*** evals perils
#+begin_src ruby
x = gets
"any user input here\n"
x.tainted?
true
#+end_src
*** define_method
#+begin_src ruby
C.class_eval { define_method ("talk") { puts var }
#+end_src
** Callbacks / Hooks
Callbacks and hooks methods are called when a particular event takes place during the run of a program.

#+begin_src ruby
#+end_src
*** method_missing
*** respond_to_missingp

** Metaprogramming
- objects and classes are first-class citizens

*** instance_variable_set
*** instance_varibles
*** class
**** instance_methods
*** Object#instance_exec
*** Module#class_exec
*** Module#module_exec
** Misc
*** misc
|                        |                                                                                                           |                                                                                                             |
|------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
| drop_while             | a.drop_while { true }                                                                                     |                                                                                                             |
| take_while             | a.take_while { true }                                                                                     |                                                                                                             |
| find_all               | a.find_all ¦ a.select                                                                                     |                                                                                                             |
| reject                 | a.reject { ¦i¦ i > 4 } ¦ a.reject! { ¦i¦ i > 4 }                                                          |                                                                                                             |
| select                 |                                                                                                           |                                                                                                             |
| grep                   | a.grep(//o//) ¦ a.grep(String) ¦ a.grep(50..100) ¦                                                          |                                                                                                             |
| group_by               | a.group_by { ¦s¦ s.size }                                                                                 |                                                                                                             |
| match                  | //n//.match(s)                                                                                              |                                                                                                             |
| String                 | 'C'.size ¦ each_byte ¦ each_line ¦ each_codepoint ¦ each_char ¦ s.bytes ¦                                 |                                                                                                             |
| min/min_by             | a.min { ¦a,b¦ a.size <=> b.size } ¦  a.min { ¦lang¦ lang.size } ¦ state_hash.min_by { ¦name, abbr¦ name } |                                                                                                             |
| max/max_by             |                                                                                                           |                                                                                                             |
| minmax/minmax_by       | a.minmax ¦ a.minmax_by { ¦lang¦ lang.size }                                                               |                                                                                                             |
| reverse_each           | [1,2,3].reverse_each { ¦e¦ puts e * 10 }                                                                  |                                                                                                             |
| with_index             | letters.each.with_index {¦(key,value),i¦ puts i }                                                         |                                                                                                             |
| each_index             | names.each.with_index(1) { ¦pres, i¦ p i }                                                                |                                                                                                             |
| each_slice             |                                                                                                           |                                                                                                             |
| each_cons              |                                                                                                           |                                                                                                             |
| slice_before           | a.slice_before(\/=/).to_a ¦ (1..10).slice_before { ¦num¦ num % 2 == 0 }.to_a ¦                            |                                                                                                             |
| slice_after            |                                                                                                           |                                                                                                             |
| slice_when             | a.slice_when { ¦i,j¦ i == j }.to_a                                                                        |                                                                                                             |
| inject/reduce          | [1,2,3,4].inject(:+)                                                                                      |                                                                                                             |
| cycle                  |                                                                                                           |                                                                                                             |
| map                    | names.map { ¦name¦ name.upcase } ¦  x = 5.times.map { Apple.new(rand(100..900)) }                         |                                                                                                             |
| map!                   |                                                                                                           |                                                                                                             |
| symbol-argument blocks | names.map(&:upcase)                                                                                       |                                                                                                             |
| <=>                    | Apple#<=> ¦ Apple.sort { ¦a,b¦ a.brand <=> b.brand } ¦                                                    | implementing a spaceship test method is enough to sort a class, or use a block to sort, or even override it |
| comparable             | Apple#<=> ¦                                                                                               | include comparable                                                                                          |
| clamp                  |                                                                                                           |                                                                                                             |
| between                |                                                                                                           |                                                                                                             |
| functions              | -> (args) {} ¦ Sum = -> (a, b) { a + b }                                                                  |                                                                                                             |
| <<                     | yielder                                                                                                   |                                                                                                             |
|                        | enum_for                                                                                                  |                                                                                                             |
|                        | to_enum                                                                                                   |                                                                                                             |
| dup                    |                                                                                                           |                                                                                                             |
|------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
*** system commands

#+begin_src ruby
`date` # => "Mon May 27 12:30:56 CDT 2013\n"

`ls`.split[34] # => "newfile"

%x{echo "hello there"} # => "hello there\n"

system('ls -lh')
#+end_src

#+begin_src ruby
alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  puts "*** Command #{cmd} failed: status = #{$?.exitstatus}" if $? != 0
  result
end
print `ls -l /etc/passwd`
print `ls -l /etc/wibble`
#+end_src

*** dig
*** fetch
*** pluck
*** succ
   increments a string value
   #+begin_src ruby
   'e'.succ # f
   #+end_src
*** append <<

*** defined?
*** writable object attribute
   #+begin_src ruby
   class ProjectList
     def initialize
       @projects = []
     end
     def projects=(list)
       @projects = list.map(&:upcase)
     end
     def [](offset)
       @projects[offset]
     end
   end

   # store list of names in uppercase
   list = ProjectList.new
   list.projects = %w{ strip sand prime sand paint sand paint rub paint }
   list[3]   # => "SAND"
   list[4]   # => "PAINT"
   #+end_src

   - attribute-setting methods
*** path
   #+begin_src ruby
   $LOAD_PATH.each { |x| puts x } or $:

   # add dir to path
   $:.push '/your/directory/here'
   require 'yourfile'
   #+end_src
** Concepts
*** Iterator
    - is a method
    - it start and finish in the same call
*** Methods
****** Enumerator
    - is an object
    - chaining
    - block based
    - method attachment (enum_for)
    - un-overriding of methods in Enumerable
    - maintain state
    - is an enumerable object
    - can add enumerability to objects
    - can stop and resume collection cycling

#+begin_src ruby
enum_in_threes = (1..10).enum_for(:each_slice, 3)
enum_in_threes.to_a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
#+end_src

Lazy

#+begin_src ruby
def Integer.all
Enumerator.new do |yielder, n: 0|
loop { yielder.yield(n += 1) }
end.lazy
end
p Integer.all.first(10) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#+end_src

** Instructions
*** Rbenv
    rbenv global 2.3.0 && rbenv rehash
*** misc
    - $! → Exception: The exception object passed to raise.
    - $@ → Array: The stack backtrace generated by the last exception.
    - $& → String : The string matched (following a successful pattern match). This variable is local to the current scope.

** Builtin Modifications
*** additive change
- adding a method that doesn’t exist.
- doesn’t clobber existing methods.
-
*** Pass-through
- overriding an existing method in such a way that the original version of the method ends up getting called along with the new version.
-
*** Additive / Pass-Through Hybrids
- is a method that has the same name as an existing core
  method, calls the old version of the method (so it’s not an out-and-out
  replacement), and adds something to the method’s interface.
-

** Reflection

#+begin_src ruby
class Hashit
  def initialize(hash)
    hash.each do |k,v|
      self.instance_variable_set("@#{k}", v.is_a?(Hash) ? Hashit.new(v) : v)
      self.class.send(:define_method, k, proc{self.instance_variable_get("@#{k}")})
      self.class.send(:define_method, "#{k}=", proc{|v| self.instance_variable_set("@#{k}", v)})
    end
  end
end
#+end_src
** Comments
   #+begin_src ruby
   # one line comment

   =begin
   multiline
   comments
   =end
   #+end_src

** Delimited input
|         |                            |
|---------+----------------------------|
| %q      | Single-quoted string       |
| %Q , %  | Double-quoted string       |
| %w , %W | Array of strings           |
| %s      | A symbol                   |
| %i , %I | Array of symbols           |
| %r      | Regular expression pattern |
| %x      | Shell command              |

- %I , %Q , and %W will preform interpolation

* Standard Library
** Packagement
*** gem
    |                             |   |
    |-----------------------------+---|
    | install <name> -v <version> |   |
    | which                       |   |
    | list                        |   |
    | search                      |   |
    | env                         |   |
    | info <name>                 |   |

#+begin_src shell-script
   gem build GEM.gemspec
   gem install --user-install pkg/GEM
   gem list GEM -d
#+end_src
** Variables
*** global variables
- $0
- $:
- $PROGRAM_NAME
- ARGV
- ARGF.{gets,filename,file,lineno,inplace_mode}
- RubyVM::DEFAULT_PARAMS

*** environment variables
#+begin_src ruby
ENV['SHELL']
ENV['HOME']
ENV['USER']
ENV.keys.size
ENV.keys[0, 4]
#+end_src

** Objects
*** exit
doesn’t terminate the program immediately — exit first raises a SystemExit exception, which you may catch, and then performs a number
of cleanup actions, including running any registered at_exit methods and object finalizers.

** Numbers
*** Fixnum
*** Bignum
** Testing
*** Minitest
**** setup

** Console
*** irb
**** cli
|                                            |                               |
|--------------------------------------------+-------------------------------|
| -r ./<file>                                |                               |
| irb_load                                   |                               |
| irb_source                                 |                               |
| --prompt <my-prompt>                       |                               |
| -I                                         | include path                  |
| RUBYOPT=--enable-frozen-string-literal irb | freeze all strings in section |
|                                            |                               |
**** inside
     |                           |         |
     |---------------------------+---------|
     | context.use_tracer = true | tracker |
     |                           |         |
** Serialization
*** JSON
**** Commands
     |                 |   |
     |-----------------+---|
     | generate <this> |   |

*** YAML
**** Commands
     |                 |               |
     |-----------------+---------------|
     | YAML.dump <obj> |               |
     | <obj>.to_yaml   | same as above |
     |                 |               |

** Documentation
*** rdoc
    - nodoc: [all]

*** console
    |        |   |
    |--------+---|
    | --all  |   |
    | --fmt  |   |
    | --main |   |

** System
*** FFI
- Foreign Function Interface
- gives you access to external libraries

#+begin_src ruby
require 'ffi'

module A
  extend FFI::Library
  ffi_lib 'c'
end
#+end_src
* Standard Modules
** continuation
   - require 'continuation'
** Require
*** require_relative
Prior Ruby 2.0

#+begin_src ruby
$: << File.dirname(__FILE__)
require 'other_file'
#+end_src

nowadays
#+begin_src ruby
require_relative 'other_file'
#+end_src
** Tempfile
- `new` creates a Tempfile object (as you would expect),
- `create` gives you a File object.

#+begin_src ruby
require 'tempfile'

Tempfile.create { |f| f << "abc\n" }
#+end_src
** IO
*** methods
**** sysopen
#+begin_src ruby
fd = IO.sysopen('/dev/null', 'w')

# 10
#+end_src
**** eof?
**** open
**** each
**** close
**** each_byte
** Dir
#+begin_src ruby
filenames = Dir.entries(".")
Dir.mkdir("testing")
Dir.exists?
Dir.chdir("/tmp") { Dir.entries(".") }
Dir.glob("*.rb")
Dir.glob("**/*.rb")
#+end_src
** FileUtils
#+begin_src ruby
require 'fileutils'

FileUtils.mkdir_p("/tmp/testing/a/b")
FileUtils.mv("/tmp/a", "/tmp/b")
#+end_src
** File
#+begin_src ruby
File.executable?
#+end_src
** Random
#+begin_src ruby
Random.bytes(10) # "\xCD\r\xE6Wz\xBA)\x02\xC4\xDB"
#+end_src
** OpenStruct

#+begin_src ruby
user = OpenStruct.new({name: "Jimmy Cool", age: "25"})
user.name #Jimmy Cool
user.age #25
#+end_src
** SecureRandom
#+begin_src ruby
require 'securerandom'

SecureRandom.bytes(10)
#+end_src
** Pathname
*** new
#+begin_src ruby
Pathname.new('/usr/local/lib/ruby/1.8')
#+end_src
*** each_filename
*** each_entry
** ObjectSpade
*** each_object
#+begin_src ruby
ObjectSpace.each_object(Numeric) {|n| puts("The number is #{n}")}

def subclasses_of(superclass)
  subclasses = []
  ObjectSpace.each_object(Class) do |k|
    next if !k.ancestors.include?(superclass) || superclass == k ||
            k.to_s.include?('::') || subclasses.include?(k.to_s)
    subclasses << k.to_s
  end
  subclasses
end

subclasses_of Numeric # ["Complex", "Rational", "Float", "Integer"]
#+end_src

** forwardable
The Forwardable module provides delegation of specified methods to a designated
object, using the methods def_delegator and def_delegators.

*** def_delegators
** Errno

** Kernel
*** variables
**** local_variables
**** global_variables
|            |                                                                          |
|------------+--------------------------------------------------------------------------|
| $:         | library load path, also available as                                     |
| $LOAD_PATH | idem                                                                     |
| $0         | name of the file in which execution of the current program was initiated |
| $FILENAME  | (the name of the file currently being executed                           |
| _          | value of the last expression evaluated by irb.                           |
|            |                                                                          |
**** itself
#+begin_src ruby

"Ruby".itself # "Ruby"
[1, 1, 3, 4, 5, 5, 5, 6, 7].itself # [1, 1, 3, 4, 5, 5, 5, 6, 7]

%w(joe, joe, david, matz, david, matz, joe).group_by { |name | name }
%w(joe, joe, david, matz, david, matz, joe).group_by(&:itself) # same as above

#+end_src

**** yield_self / then
- named to `then` in 3.0

#+begin_src ruby

"Ruby".yield_self { |str| str + " meh" }

add_newline = -> (str) { str + "\n" }
welcome = -> (str) { "Welcome, " + str.upcase + "!" }
"joe".yield_self(&welcome).yield_self(&add_newline) + "We’re glad you’re here!" # "Welcome, JOE!\nWe’re glad you’re here!"

# then
(1..10).then { |r| r.member?(rand(15)) } # returns true or false
(rand(10) + 1).then { |x| x.odd? ? x + 1 : x } # returns an even number between 2 and 10.

#+end_src
** ObjectSpace
The objspace library extends the ObjectSpace module and adds several
methods to get internal statistic information about object/memory
management.
** Enumerable

*compact*

#+begin_src ruby

enum = [1, nil, 3, nil, 5].to_enum.compact
enum = [1, nil, 3, nil, 5].to_enum.lazy.compact

 #+end_src

*group_by*

#+begin_src ruby

%w(joe, joe, david, matz, david, matz, joe).group_by { |name | name }
# {"joe,"=>["joe,", "joe,"], "david,"=>["david,", "david,"], "matz,"=>["matz,", "matz,"], "joe"=>["joe"]}

#+end_src

*cycle*

When called with positive Integer argument count and a block, calls the
block with each element, then does so again, until it has done so count
times; returns nil


#+begin_src ruby
[12, 18, 20, 02].cycle(3) { |el| puts el*4 } # 48 72 80 8 48 72 80 8 48 72 80                  8
#+end_src

*filter_map*

combine the select & map

#+begin_src ruby
(1..8).select(&:even?).map { |n| n ** 2 }
# OR
(1..8).map { |n| n ** 2 if n.even? }.compact

# ruby 2.7
(1..8).filter_map { |n| n ** 2 if n.even? } # [4, 16, 36, 64]
#+end_src

*grep*

#+begin_src ruby

['gr', 'xr', 'cd', 'dg'].grep /r/ # ["gr", "xr"]
['gr', 'xr', 1, 2].grep Integer # [1, 2]
["apple", "orange", "banana"].grep(/^a/)
["apple", "orange", "banana"].grep(/e$/)
[9, 10, 11, 20].grep(5..10) # [9, 10]
[9, 10, 11, 20].grep(5..10) { |n| n * 2 } # [18, 20]

times_two = ->(x) { x * 2 }
numbers.grep(5..10, &times_two) # [18, 20]

#+end_src

*tally*
counts all the elements in an array & returns a hash with their counts.

#+begin_src ruby
%w(a a a b b c).tally
#+end_src

*all?*

*sort*

*examples*
#+begin_src ruby
class Account
  attr_accessor :name, :balance

  def initialize(name, balance)
    @name = name
    @balance = balance
  end

  def <=>(other)
    balance <=> other.balance
  end
end

class Portfolio
  include Enumerable

  def initialize
    @accounts = []
  end

  def each(&block)
    @accounts.each(&block)
  end

  def add_account(account)
    @accounts << account
  end
end

my_portfolio.any? {|account| account.balance > 2000}
my_portfolio.all? {|account| account.balance > = 10}
#+end_src


#+begin_src ruby
class VowelFinder
  include Enumerable
  def initialize(string)
    @string = string
  end

  def each(&block)
    @string.scan(/[aeiou]/, &block)
  end
end
vf = VowelFinder.new('the quick brown fox jumped')
vf.inject(:+) # => "euiooue"
#+end_src

#+begin_src ruby
# iterate over only those lines that end with a d
File.open("ordinal").grep(/d$/) do |line|
  puts line
end
#+end_src

*::ArithmethicSequence*

#+begin_src ruby
(1..10).step(2).first
# 1

(1..10).step(2).last
# 9
#+end_src

*none?*

#+begin_src ruby
strings.none? { |str| str.size == 5 }
#+end_src

*any?*

#+begin_src ruby
[:orange, :apple, :coconut].any?(Symbol) # true
#+end_src

*all?*

#+begin_src ruby
[1,2,3].all?(1..10) # true
#+end_src

*one?*

#+begin_src ruby
["a", 1, {}].one? { |obj| obj.kind_of?(Hash) }
# true

["a"].one?
# true

[].one?
# false

[nil].one?
# false
#+end_src

** Enumerator
*lazy*

#+begin_src ruby
def Integer.all
  Enumerator.new do |yielder, n: 0|
	  loop { yielder.yield(n += 1) }
  end.lazy
end


def find_multiples(num, mult)
  (1..Float::INFINITY).lazy.select { |x| x % mult == 0}.first(num)
end
find_multiples(3, 50) # [50, 100, 150]


first_3_multiples = self.method(:find_multiples).curry.(3) # #<Proc:0x000055c3b7d76088 (lambda)>
first_5_multiples = self.method(:find_multiples).curry.(5) # #<Proc:0x000055c3b8243368 (lambda)>
first_3_multiples.(256) # [256, 512, 768]


squares = (1..Float::INFINITY).lazy.map { |x| x * x } # #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:map>
squares.first 4 # [1, 4, 9, 16]

#+end_src

*each_car*

*each*

*to_enum/enum_for*

#+begin_src ruby
a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "vulpine" }

# Create Enumerators
enum_a = a.to_enum
enum_h = h.to_enum

enum_a.next # 1
enum_h.next # [:dog, "canine"]
enum_a.next # 3
enum_h.next # [:fox, "vulpine"]

enum_a = a.each # create an Enumerator using an internal iterator
#+end_src

*enum_for*

#+begin_src ruby
e = names.enum_for(:inject, "Names: ")
#+end_src

*generator*

*produce*

Produces an infinite sequence where each next element is calculated by applying
the block to the previous element.

#+begin_src ruby
Enumerator.produce(1, &:next).take(5) # [1, 2, 3, 4, 5]
#+end_src

*upto*

#+begin_src ruby
0.upto(9).each(&method(:puts))
#+end_src
** Comparable

#+begin_src ruby
class Person
include Comparable
attr_reader :name
def initialize(name)
@name = name
end
def to_s
"#{@name}"
end
def <=>(other)
self.name <=> other.name
end
end
p1 = Person.new("Matz")
p2 = Person.new("Guido")
p3 = Person.new("Larry")
# Compare a couple of names
if p1 > p2
puts "#{p1.name}'s name > #{p2.name}'s name"
end
# Sort an array of Person objects
puts "Sorted list:"
puts [ p1, p2, p3].sort
#+end_src
** Iterators
- internal iterator
- external iterator

#+begin_src ruby
3.times { p 'meh' } # easy to avoid fence-post and off-by-one errors

9.downto(5) { p 'meh' }

0.upto(9) { p 'meh' }

0.step(12, 3) {|x| print x, " " }

[ 1, 1, 2, 3, 5 ].each {|val| print val, " " }
#+end_src

*** collect
   #+begin_src ruby
   ["H", "A", "L"].collect {|x| x.succ } # => ["I", "B", "M"]
   #+end_src
*** each
*** select/inject
   accumulate a value across the members of a collection
*** each_cons(<value>)
*** find
   #+begin_src ruby
   a.find { ¦n¦ n > 5 }
   a.find { ¦n¦ n > 5 }
   a.find_all
   a.select
   a.reject
   a.map
   #+end_src

*** each_slice
   #+begin_src ruby
   animals.each_slice(2).map do |predator, prey|
   #+end_src
*** each_with_object
*** with_object
*** with_index.
*** reject

*** each_byte

*** each_char
*** tap
*** with_index
   #+begin_src ruby
   ['a'..'z').map.with_index {|letter,i| [letter, i] } // Output: [["a", 0], ["b", 1], etc.]
   my_enum.take(5).force // actual result rather than lazy enumerator
   #+end_src
*** times
** TracePoint
Helps you trace events like method calls, class definitions & threads.

*parameters*

#+begin_src ruby
TracePoint.trace(:call, :b_call, :c_call) do |tp|
  p [tp.event, tp.parameters]
end

def orange(a,b,c*)
end

orange(1,2,3)

# [:call, [[:req, :a], [:req, :b], [:rest, :c]]]
#+end_src
* Cli
** ruby

|           |   |
|-----------+---|
| -l        |   |
| -I  <lib> |   |
** gem
|                    |   |
|--------------------+---|
| search             |   |
| list               |   |
| query              |   |
| install            |   |
| environment gemdir |   |
| build              |   |
| server             |   |

** irb

** ri
ri <ClassName>

#+begin_src shell
ri GC
ri assoc
ri Rake

export RI="--format ansi --width 70"
#+end_src

* Toolings
** Online
https://rubular.com

* Best Practices
** Methods
- methods have four parts
  1. Collecting input
  2. Performing work
  3. Delivering output
  4. Handling failures
 - asd
   1. We must identify the messages we want to send in order to accomplish the task at hand.
   2. We must identify the roles which correspond to those messages.
   3. We must ensure the method's logic receives objects which can play those roles
* Tips
** Container
- keep gems in volume
- keep current folder in volume
- workdir is app
- run commands as bash
- apt distro

#+begin_src shell
docker run --rm -v $(pwd):/app/ -v bundle_apps:/usr/local/bundle -w /app ruby:3.1.1 bash -c 'bundle install'
#+end_src

#+begin_src sh
docker run --rm -v $(pwd):/app/ -w /app ruby:3.1.1 bash -c 'mkdir -p ~/.config && cp -r examples ~/.config/pak && bundle && exe/pak search git'
#+end_src
