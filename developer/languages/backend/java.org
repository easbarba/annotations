#+TITLE: Java

* Progress
** Books
| name                     | chapter                                                    | @                 |
|--------------------------+------------------------------------------------------------+-------------------|
| Java Complete Reference  | 14 Generics                                                | Bounded Wildcards |
| Java Precisely           | 16 Compilation, Source Files, Class Names, and Class Files |                   |
| Junit                    | 1                                                          |                   |
| Coding Interview in Java | 3 Common Non-Technical Questions and How To Answer Them    |                   |
| Effective Java 9         | 2 Creating and Destroying Objects                          |                   |

** SLOC
| Source Code | folder                               | file           | @ |
|-------------+--------------------------------------+----------------+---|
| openjdk     | src/java.base/share/classes/java/io  | Bits.java      |   |
| common-cli  | src/main/java/org/apache/commons/cli | GnuParser.java |   |

* Base
** Types
- Can’t pass a primitive type by reference

*** Integers
- are signed, positive and negative values

**** byte
- smallest integer type
- –128 to 127

#+begin_src java
byte b, c;
#+end_src

**** short
- range from –32,768 to 32,767

#+begin_src java
short s;
short t;
#+end_src
**** int
- range from –2,147,483,648 to 2,147,483,647
- byte and short values in expressions are promoted to int when evaluated
#+begin_src java
int x = 0b1010; // integer binary
int y = 123_456_789;
int y = 123___456___789;
#+end_src
**** long
*** Floating
- real numbers
- IEEE–754
- defaults to double precision
- supports hexadecimal floating-point

#+begin_src java
0x12.2P2 // hexadecimal fp
double num = 9_423_497_862.0;
#+end_src

**** float
- 1.4e–045 to 3.4e+038
- single-precision
- takes half as much space as double precision
- imprecise when the values are either very large or very small

#+begin_src java
float hightemp, lowtemp;
#+end_src
**** double
- 4.9e–324 to 1.8e+308

#+begin_src java
// Compute the area of a circle.
class Area {
    public static void main(String[] args) {
        double pi, r, a;
        r = 10.8; // radius of circle
        pi = 3.1416; // pi, approximately
        a = pi * r * r; // compute area
        System.out.println("Area of circle is " + a);
    }
}
#+end_src
*** Strings
#+begin_src java
"Hello World"
"two\nlines"
" \"This is in quotes\""
"foo" + " bar" // "foo bar"
#+end_src

**** String Builder
- java.lang.StringBuilder
- gradually build a string

#+begin_src java
new StringBuilder()
#+end_src

*.append(string)*
#+begin_src java
new StringBuilder("meh").append(" foo").append(" bar").toString()
#+end_src

*.charAt(int)*

*.delete(from, to)*

*.insert(from, v)*

*.length()*

*.replace(from, to, s)*

*.reverse()*

*.setCharAt(i,c)*

*.toString()*

**** String Buffers
- same as Builder
- thread-safe

*** Characters
- store characters
- range of 0 to 65,535
- able to manipulate with the integer operators

#+begin_src java
'\u0061' // ISO-Latin-1 'a'
'\ua432 ' // ꐲ - Japanese Katakana character.

// Demonstrate char data type.
class CharDemo {
    public static void main(String[] args) {
        char ch1, ch2;
        ch1 = 88; // code for X
        ch2 = 'Y';
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
    }
}
#+end_src

*** Boolean
- true
- false
- wont convert into any numerical representation

#+begin_src java
// Demonstrate boolean values.
class BoolTest {
    public static void main(String[] args) {
        boolean b;
        b = false;
        System.out.println("b is " + b);
        b = true;
        System.out.println("b is " + b);
        // a boolean value can control the if statement
        if(b) System.out.println("This is executed.");
        b = false;
        if(b) System.out.println("This is not executed.");
        // outcome of a relational operator is a boolean value
        System.out.println("10 > 9 is " + (10 > 9));

    }
}
#+end_src
** Collection Types
*** Arrays
*new*
#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
int[] myNum = {10, 20, 30, 40};
#+end_src

*acessing*

#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars[0]);
#+end_src

*change value*

#+begin_src java
cars[0] = "Opel";
#+end_src

*length*

#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars.length);
#+end_src

*asList*
*fill*
*copyOf*
*compare*
*sort*
** Packages
- must be stored in sub-directories represented in the dot path
- A class declared in a source file with no package declaration belongs to the anonymous default package

#+begin_src java
import p.C;
import p.*;
import static p.C.*;

package org.foo.bar
#+end_src

*importing*
- optional, as oposing fully qualified name usage.

- fully qualified
#+begin_src java
class MyDate extends java.util.Date {
...
}
#+end_src

#+begin_src java
import java.util.Date;
import java.io.*;

class MyDate extends Date {
}
#+end_src

** Classes
*** Member Access
*** Local Classes
A local class is declared locally within a block of Java code, rather than as a
member of a class.
#+begin_src java
    // This method creates and returns an Enumeration object
public java.util.Enumeration enumerate() {
    // Here's the definition of Enumerator as a local class
    class Enumerator implements java.util.Enumeration {
        Linkable current;

        public Enumerator() {
            current = head;
        }

        public boolean hasMoreElements() {
            return (current != null);
        }

        public Object nextElement() {
            if (current == null)
                throw new java.util.NoSuchElementException();
            Object value = current;
            current = current.getNext();
            return value;
        }
    }
    // Now return an instance of the Enumerator class defined directly above
    return new Enumerator();
}
#+end_src

** Modifiers
*** final
#+begin_src sh
final int
#+end_src
On methods prevent it to be overriden
#+begin_src sh
final void meth() {
System.out.println("This is a final method.");
}
#+end_src

** Variables
- an identifier, a type, and an optional initialize
- has a scope, which defines their visibility, and lifetime
- must be declared before being used

#+begin_src java
int a, b, c;
int d = 3, e, f = 5;
byte z = 22;
double pi = 3.14159;
char x = 'x';
#+end_src
** Classes
*** Access Control
**** Public
- can be accessed by any other code
- default access
**** Private
- can only be accessed by other members of its class.
**** Protected
- applies only when inheritance is involved
*** Static
- can only directly call other static methods of their class
- can only directly access static variables of their class.
- cannot refer to this or super
- are, essentially, global variables
*** Final
- prevents its contents from being modified, making it, essentially, a constant.
- you must initialize a final field when it is declared.
- can give it a value when it is declared or assign it a value within a constructor


- prevents methods overriding
- sometimes provide a performance enhancement (inline calls)

#+begin_src java
class A {
	final void meth() {
		System.out.println("This is a final method.");
	}
}
class B extends A {
	void meth() { // ERROR! Can't override.
		System.out.println("Illegal!");
	}
}
#+end_src

- prevents inheritance

#+begin_src java
final class A {
	//...
}
// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
	//...
}
#+end_src
*** Seal
*** Inheritance
- inherits all from super object
- single-inheritance
- private on superclass elements are not inherited by subclasses

#+begin_src java
class A {
	int i, j;
	void showij() {
		System.out.println("i and j: " + i + " " + j);
	}
}
// Create a subclass by extending class A.
class B extends A {
	int k;
	void showk() {
		System.out.println("k: " + k);
	}
	void sum() {
		System.out.println("i+j+k: " + (i+j+k));
	}
}
#+end_src
*** super
- must always be the first statement executed inside a subclass’ constructor.
*** Abstract Classes
Defines a superclass that declares the structure of a given abstraction without
providing a complete implementation of every method.

#+begin_src java
// A Simple demonstration of abstract.
abstract class A {
  abstract void callme();
  // concrete methods are still allowed in abstract classes
  void callmetoo() { System.out.println("This is a concrete method."); }
}

class B extends A {
  void callme() { System.out.println("B's implementation of callme."); }
}

class AbstractDemo {
  public static void main(String[] args) {
    B b = new B();
    b.callme();
    b.callmetoo();
  }
}
#+end_src
*** useful methods to implement
#+begin_src java
equals()
hashCode()
toString()
#+end_src
** Interfaces
- Cannot mantain state
- JDK 7: an interface could not define any implementation whatsoever.
- JDK 8: adds a default implementation to an interface method.
- JDK 8: adds static interface methods
- JDK 9: includes private methods

#+begin_src java
interface Callback {
    void callback(int param);
}
#+end_src

- variables are implicitly final and static
- methods and variables are implicitly public.
- interface's method must be public

#+begin_src java
class Client implements Callback { // interface's method must be public
// Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }
}
#+end_src

#+begin_src java
class Client implements Callback {
    // Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }

    void nonIfaceMeth() {
        System.out.println("Classes that implement interfaces " + "may also define other members, too.");
    }
}
#+end_src

Interface as variable reference
- An interface reference variable has knowledge only of the methods declared by its interface declaration.

#+begin_src java
class TestIface {
    public static void main(String[] args) {
        Callback c = new Client();
        c.callback(42);
    }
}
#+end_src

Partial Implementations
- not fully implement the methods required by that interface, then that class must be declared as abstract.
- Any class that inherits Incomplete must implement callback( ) or be declared abstract itself.

#+begin_src java
abstract class Incomplete implements Callback {
    int a, b;

    void show() {
        System.out.println(a + " " + b);
    }
    // ...
}
#+end_src

Nested Interfaces

- member interfaces
- can be declared as public, private, or protected.
- differs from a top-level interface, which must either be declared as public or use the default access level


#+begin_src java
class A {
    // this is a nested interface
    public interface NestedIF {
        boolean isNotNegative(int x);
    }
}

// B implements the nested interface.
class B implements A.NestedIF {
    public boolean isNotNegative(int x) {
        return x < 0 ? false : true;
    }
}

class NestedIFDemo {
    public static void main(String[] args) {
        // use a nested interface reference
        A.NestedIF nif = new B();
        if (nif.isNotNegative(10))
            System.out.println("10 is not negative");
        if (nif.isNotNegative(-12))
            System.out.println("this won't be displayed");
    }
}
#+end_src

Extending interfaces

- must provide implementations for all methods required by the interface inheritance chain

#+begin_src java
// One interface can extend another.
interface A {
    void meth1();
    void meth2();
}

// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A {
    void meth3();
}

// This class must implement all of A and B
class MyClass implements B {
    public void meth1() {
        System.out.println("Implement meth1().");
    }

    public void meth2() {
        System.out.println("Implement meth2().");
    }

    public void meth3() {
        System.out.println("Implement meth3().");
    }
}

class IFExtend {
    public static void main(String[] args) {
        MyClass ob = new MyClass();
        ob.meth1();
        ob.meth2();
        ob.meth3();
    }
}
#+end_src

Default method

- extension method
- provide a body, rather than being abstract.
- supplies an implementation that will be used if no other implementation is explicitly provided
- JDK 8

#+begin_src java
interface IntStack {
    void push(int item); // store an item
    int pop(); // retrieve an item
    // Because clear( ) has a default, it need not be
    // implemented by a preexisting class that uses IntStack.
    default void clear() {
        System.out.println("clear() not implemented.");
    }
}
#+end_src

- refers to a default implementation in an inherited interface by using super.

#+begin_src
Alpha.super.reset();
#+end_src

*Interface static Methods*

- no implementation of the interface is necessary, and no instance of the interface is required, in order to call a static method.

#+begin_src java
public interface MyIF {
    // This is a "normal" interface method declaration.
    // It does NOT define a default implementation.
    int getNumber();

    // This is a default method. Notice that it provides
    // a default implementation.
    default String getString() {
        return "Default String";
    }

    // This is a static interface method.
    static int getDefaultNumber() {
        return 0;
    }
}

// ...
int defNum = MyIF.getDefaultNumber();
#+end_src

*Private Interface Methods*

- only called by a default method or another private method defined by the same interface.
- cannot be used by code outside the interface in which it is defined, including subinterfaces
- used as a shared common piece of code

#+begin_src java
// Another version of IntStack that has a private interface
// method that is used by two default methods.
interface IntStack {
    void push(int item); // store an item

    int pop();
    // retrieve an item

    // A default method that returns an array that contains
    // the top n elements on the stack.
    default int[] popNElements(int n) {
        // Return the requested elements.
        return getElements(n);
    }

    // A default method that returns an array that contains
    // the next n elements on the stack after skipping elements.
    default int[] skipAndPopNElements(int skip, int n) {
        // Skip the specified number of elements.
        getElements(skip);
        // Return the requested elements.
        return getElements(n);
    }

    // A private method that returns an array containing
    // the top n elements on the stack
    private int[] getElements(int n) {
        int[] elements = new int[n];
        for (int i = 0; i < n; i++)
            elements[i] = pop();
        return elements;
    }
}
#+end_src
** Exceptions
- can be generated by the Java run-time system
- can be manually generated by your code
- all exception types are subclasses of the built-in class Throwable

#+begin_src java
try {
// block of code to monitor for errors
}
catch (ExceptionType1 exOb) {
// exception handler for ExceptionType1
}
catch (ExceptionType2 exOb) {
// exception handler for ExceptionType2
}
// ...
finally {
// block of code to be executed after try block ends
}
#+end_src
*** Keywords
*try/catch*
- allows you to fix the error
- prevents the program from automatically terminating
- well-constructed catch clauses should be to resolve the exceptional condition and then continue on as if the error had never happened.
#+begin_src java
class Exc2 {
  public static void main(String[] args) {
    int d, a;
    try { // monitor a block of code.
      d = 0;
      a = 42 / d;
      System.out.println("This will not be printed.");
    } catch (ArithmeticException e) { // catch divide-by-zero error
      System.out.println("Division by zero.");
    }
    Chapter 10 Exception Handling 231 System.out.println(
        "After catch statement.");
  }
}
#+end_src

*throw*

*throws*

*finally*

*Exception class*
- for exceptional conditions that user programs should catch.
- for class that you will subclass to create your own custom exception types.

*Error class*
- indicates errors having to do with the run-time environment
- exceptions that are not expected to be caught under normal circumstances by your program.
*** Types
** Enumerations
- specifies the only values that a data type can legally have.
- can have constructors, methods, and instance variables.
- can have constructors, add instance variables and methods, and even implement interfaces
- inherits from java.lang.Enum

#+begin_src java
enum Apple {
    Jonathan, GoldenDel, RedDel, Winesap, Cortland
}

class EnumDemo {
  public static void main(String[] args) {
    Apple ap;
    ap = Apple.RedDel;
    // Output an enum value.
    System.out.println("Value of ap: " + ap);
    System.out.println();
    ap = Apple.GoldenDel;
    // Compare two enum values.
    if (ap == Apple.GoldenDel)
      System.out.println("ap contains GoldenDel.\n");
    // Use an enum to control a switch statement.
    switch (ap) {
    case Jonathan:
      System.out.println("Jonathan is red.");
      break;
    case GoldenDel:
      System.out.println("Golden Delicious is yellow.");
      break;
    case RedDel:
      System.out.println("Red Delicious is red.");
      break;
    case Winesap:
      System.out.println("Winesap is red.");
      break;
    case Cortland:
      System.out.println("Cortland is red.");
      break;
    }
  }
}
#+end_src

*values*
Returns an array that contains a list of the enumeration constants

#+begin_src java
public static enum-type [ ] values( )
#+end_src

*valueOf*

Returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
public static enum-type valueOf(String str )
#+end_src

returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
enum Apple { Jonathan, GoldenDel, RedDel, Winesap, Cortland }
class EnumDemo2 {
  public static void main(String[] args) {
    Apple ap;
    System.out.println("Here are all Apple constants:");
    // use values()
    Apple[] allapples = Apple.values();
    for (Apple a : allapples)
      System.out.println(a);
    System.out.println();
    // use valueOf()
    ap = Apple.valueOf("Winesap");
    System.out.println("ap contains " + ap);
  }
}
#+end_src

*constructor*

#+begin_src java
// Use an enum constructor, instance variable, and method.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel(12),
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  int getPrice() { return price; }
}

class EnumDemo3 {
  public static void main(String[] args) {
    Apple ap;

    System.out.println("Winesap costs " + Apple.Winesap.getPrice() +  " cents.\n");

    System.out.println("All apple prices:");
    for (Apple a : Apple.values())
      System.out.println(a + " costs " + a.getPrice() + " cents.");
  }
}
#+end_src

- multiple constructors

#+begin_src java
// Use an enum constructor.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel,
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  // Overloaded constructor
  Apple() { price = -1; }
  int getPrice() { return price; }
}
#+end_src

*ordinal*

indicates an enumeration constant’s position in the list of constants.

#+begin_src java
ap.Winesap.ordinal() // 3
#+end_src

*compareTo*

#+begin_src java
ap.Winesap.compareTo(ap.Cortland) // -1
#+end_src

*equals*

#+begin_src java
ap.Winesap.equals(ap.Cortland) // false
 m.Winesap == m.Cortland // false
#+end_src
** Streams
** Annotations
- @ declares an  annotation type to the compiler
- annotation can be annotated.
- JDK 8: adds the ability to annotate type use
-
#+begin_src java
// A simple annotation type.
@interface MyAnno {
    String str();
    int val();
}
#+end_src

*Meta Annotations*

*Retention Policies*
- determines at what point an annotation is discarded: SOURCE, CLASS, and RUNTIME
- SOURCE: retained only in the source file and is discarded during compilation.
- CLASS: stored in the .class file during compilation. However, it is not available through the JVM during run time.
- RUNTIME: stored in the .class file during compilation and is available through the JVM during run time. Thus, RUNTIME retention
offers the greatest annotation persistence.

#+begin_src java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str();
    int val();
}
#+end_src

*getAnnotation*
- returns a reference to the annotation
- returns null if the annotation is not found

#+begin_src java
<A extends Annotation> getAnnotation(Class<A> annoType)
#+end_src

#+begin_src java
import java.lang.annotation.*;
import java.lang.reflect.*;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str();
  int val();
}

class Meta {
  // myMeth now has two arguments.
  @MyAnno(str = "Two Parameters", val = 19)
  public static void myMeth(String str, int i) {
    Meta ob = new Meta();
    try {
      Class<?> c = ob.getClass();
      // Here, the parameter types are specified.
      Method m = c.getMethod("myMeth", String.class, int.class);
      MyAnno anno = m.getAnnotation(MyAnno.class);
      System.out.println(anno.str() + " " + anno.val());
    } catch (NoSuchMethodException exc) {
      System.out.println("Method Not Found.");
    }
  }
  public static void main(String[] args) { myMeth("test", 10); }
}
#+end_src

*getAnnotations*

#+begin_src java
Annotation[ ] getAnnotations( )
#+end_src

#+begin_src java
Meta2 ob = new Meta2();
Annotation[] annos = ob.getClass().getAnnotations();

Method m = ob.getClass( ).getMethod("myMeth");
annos = m.getAnnotations();
#+end_src

*Default Values*
Default values that will be used if no value is specified when the annotation is applied

#+begin_src java
type member( ) default value ;
#+end_src

#+begin_src java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str() default "Testing";
    int val() default 9000;
}

@MyAnno() // both str and val default
@MyAnno(str = "some string") // val defaults
@MyAnno(val = 100) // str defaults
@MyAnno(str = "Testing", val = 100) // no defaults
#+end_src

*Marker Annotations*

** Generics
Creates classes, interfaces, and methods that will work in a type-safe manner
with various kinds of data

- Parameterized types
- Any valid identifier could have been used, but T is traditional.
- Recommended that type parameter names be single-character capital letters (T,V,E)
- In essence, through generics, run-time errors are converted into compile-time errors

|        |                                                |
|--------+------------------------------------------------|
| JDK 10 | Cannot use var as the name of a type parameter |
|        |                                                |

#+begin_src java
class-name<type-arg-list > var-name = new class-name<type-arg-list >(cons-arg-list);
#+end_src

- as constructor param
#+begin_src java
Gen(T o) {
    ob = o;
}
#+end_src

- as a method return type

#+begin_src java
T getOb() {
    return ob;
}
#+end_src

- the type argument passed to the type parameter must be a reference type
#+begin_src java
Gen<Integer> intOb = new Gen<Integer>(53); // Correct!
Gen<int> intOb = new Gen<int>(53); // Error, can't use primitive type
#+end_src

#+begin_src java
class Gen<T> {
  T ob;

  Gen(T o) {
    ob = o;
  }

  T getOb() {
    return ob;
  }

  void showType() {
    System.out.println("Type of T is " + ob.getClass().getName());
  }
}

public static void main(String[] args) {
  Gen<Integer> iOb;

  iOb = new Gen<Integer>(88);

  iOb.showType();

  int v = iOb.getOb();

  Gen<String> strOb = new Gen<String>("Generics Test");

  strOb.showType();

  String str = strOb.getOb();
}
#+end_src

*more than one type parameter*

#+begin_src java
class TwoGen<T, V> {
    T ob1;
    V ob2;

    TwoGen(T o1, V o2) {
        ob1 = o1;
        ob2 = o2;
    }

    void showTypes() {
        System.out.println("Type of T is " + ob1.getClass().getName());
        System.out.println("Type of V is " + ob2.getClass().getName());
    }

    T getOb1() {
        return ob1;
    }

    V getOb2() {
        return ob2;
    }
}

class SimpGen {
    public static void main(String[] args) {
        TwoGen<Integer, String> tgObj = new TwoGen<Integer, String>(88, "Generics");

        tgObj.showTypes();

        int v = tgObj.getOb1();
        System.out.println("value: " + v);

        String str = tgObj.getOb2();
        System.out.println("value: " + str);
    }
}
#+end_src

*Bounded Types*
Limit the types that can be passed to a type parameter.
- can also use a type intersection in a cast.

#+begin_src java
class Stats<T extends Number> {
  T[] nums;

  Stats(T[] o) { nums = o; }

  double average() {
    double sum = 0.0;
    for (int i = 0; i < nums.length; i++)
      sum += nums[i].doubleValue();
    return sum / nums.length;
  }
}

// multiple bounded types
class Gen<T extends MyClass & MyInterface> {}
#+end_src

*Wildcard Arguments*
The wildcard argument is specified by the ?, and it represents an unknown type.

#+begin_src java
// Notice the use of the wildcard.
boolean isSameAvg(Stats<?> ob) {
  if(average() == ob.average())
    return true;

  return false;
}
#+end_src

*Bounded Wildcards*



** Autoboxing
** Type Wrappers
- classes that encapsulate a primitive type within an object.

*Character*
- JDK 9: the Character constructor was deprecated,
- JDK 16: it has been deprecated for removal.
 - Its recommended that you use the static method valueOf( ) to obtain a Character object.

#+begin_src java
static Character valueOf(char ch)
#+end_src

Get value contained in a Character object,
#+begin_src java
char charValue( )
#+end_src

*Boolean*

#+begin_src java
static Boolean valueOf(boolean boolValue)
static Boolean valueOf(String boolString)
#+end_src
#+begin_src java
boolean booleanValue( )
#+end_src

*numeric*

#+begin_src java
static Integer valueOf(int val)
static Integer valueOf(String valStr) throws NumberFormatException
#+end_src

* Standard Library
** java.lang
** java.lang.reflect
*** AnnotatedElement

- Interface
- java.lang.reflect

#+begin_src java
Annotation[ ] getDeclaredAnnotations( )
#+end_src

#+begin_src java
Annotation[ ] getAnnotations( )
#+end_src


#+begin_src java
<A extends Annotation> getAnnotation(Class<A> annoType)
#+end_src

#+begin_src java
default boolean isAnnotationPresent(Class<? extends Annotation> annoType)
#+end_src

#+begin_src java
getDeclaredAnnotation( )
getAnnotationsByType()
getDeclaredAnnotationsByType( )
#+end_src

* Commands
** java
launch a Java application

*-jar*

#+begin_src java
java -jar target/taco-cloud-0.0.1-SNAPSHOT.jar
#+end_src

*-cp*

#+begin_src shell
java -cp target/zae-1.0-SNAPSHOT.jar org.easbarba.zae.App
#+end_src

*-m or --module module[/mainclass]*

*--list-modules*

*cp*

#+begin_src shell
java -cp target/cdeps-0.1.0.jar clojure.main -m com.tomekw.cdeps.core
#+end_src

** jlink
#+begin_src sh
jlink --add-modules java.base --output javao
#+end_src
** jar
#+begin_src shell
jar vcf p.jar c
#+end_src
** javac
Read Java declarations and compile them into class files
** javadoc
** javap
** jshell

* Utilities
- jlink
- jpackage
  -
* Environment Variables
*JAVA_HOME*
*JDK_JAVA_OPTIONS*

* Library
** String
** Object
- superclass of all other classes
- reference variable of type Object can refer to an object of any other class.
*** methods
|           |   |
|-----------+---|
| clone     |   |
| equals    |   |
| finalize  |   |
| getClass  |   |
| hashCode  |   |
| notify    |   |
| notifyAll |   |
| toString  |   |
| wait      |   |

*** Passed as Param
- Pass as reference, will change the object passsed as param outside of method.
* Scripting
- remove .java extension
- chmod +x
- add shebang w/ *--source N*
- java dependencies can be added w/ *-cp /path/to/xxx.jar*

#+begin_src java
#!/usr/bin/java --source 17

public class HelloScripting {
	public static void main(String[] args) {
		System.out.println("Hello " + args[0]);
	}
}

#+end_src
* Projects idea
** misc
xcdesz4 points7 hours ago
The Baeldung spring-boot tutorials are excellent and pretty beginner friendly. I use them even after doing this stuff for years.

If you are going into java, Spring-Boot is probably something you must learn. For starters, make a basic rest-api for a CRUD app, using JPA to write to a SQL database, like PostGres. That is the standard baseline for most java projects that you will encounter in the wild.

Also learn how to write unit tests for the backend endpoints. Learn Git as well, and you will fit right in to most java teams.

A simple spring boot project with static apis would be great, make sure you are familiar with maven or gradle. Get use to postman and calling them locally. Then add a database like postgres and interface it with spring data. After that's working with simple CRUD apis then you can start looking at something like docker or testing or w.e youre interested in. The key is just start small and keep adding onto it. I did something like this awhile ago.
* Jobs
** oracle backend
BS or MS degree in Computer Science or related field
3+ years of professional experience in industry
Experienced and efficient programmer in Java
Demonstrable strong programming skills in core Java by writing performant and extensible code
Firm grasp of cloud software concepts
Good familiarity and understanding of software design patterns
Experience writing well-maintainable RESTful web services
Experience with REST APIs, JSON, Web Security, and micro-services architecture
Basic understanding of distributed systems
Eager to work on a highly scalable, performance optimized infrastructure which elastically handles customer needs
Ability to adapt to a fast-paced work environment and can quickly adjust to changing priorities
Detail oriented with focus on quality of the product, data, and code
Fluency in spoken/read/written English
** redhat senior java
Broad experience with technologies like Apache Kafka, Keycloak, API Management, Apache Camel and Fuse, Spring Boot, microservices, and serverless and functions
3+ years of experience working in a top-tier systems vendor, either in software engineering, consulting, sales engineering, or a solutions architect role
5+ years of experience with full life cycle application development, including proven architecture experience, e.g., agile methodology, continuous integration and continuous delivery (CI/CD), test-driven development (TDD), service-oriented architecture (SOA), message-oriented middleware (MOM), governance, high availability, scaling, distributed applications, clustering, etc.
3+ years of experience with cloud, e.g., Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure, and container technologies, mainly Docker and Kubernetes or Red Hat OpenShift Container Platform
Ability to develop excellent presentation skills; ability to present to small and large groups of mixed audiences like business, technical, management, and leadership
Excellent written and verbal communication skills in English
Willingness to travel up to 50% of the time, within the North America region, when needed for events and meetings
Project lead, architecture design, or sales engineering experience is a plus
Bachelor's or master's degree is a plus
** Kamila code
- lambda
- stream
- datetime
- git
- linux
- api rest
- http
- maven
- gradle
- spring: web boot data security
- test unit junit mockito piramede test
- swagger
- nuvem: aws
- mensageria
- scrum, agile
- microserviços
** Vincius Godoy
Com certeza, pode ficar no final da lista. Nesse meio tempo vale mais a pena estudar algumas tecnologias importantes como a Collections, o JPA e o SpringBoot. Além de aprofundar o uso de reflexão e anotations.
