#+TITLE: Java

* Progress
** Books
| name                     | chapter                                                    | @                  |
|--------------------------+------------------------------------------------------------+--------------------|
| Java Complete Reference  | Chapter 12  Enumerations, Autoboxing, and Annotations      | Marker Annotations |
| Coding Interview in Java | 3 Common Non-Technical Questions and How To Answer Them    |                    |
| Effective Java 9         | 2 Creating and Destroying Objects                          |                    |
| Java Precisely           | 16 Compilation, Source Files, Class Names, and Class Files |                    |

** SLOC
| Source Code | folder                               | file           | @ |
|-------------+--------------------------------------+----------------+---|
| openjdk     | src/java.base/share/classes/java/io  | Bits.java      |   |
| common-cli  | src/main/java/org/apache/commons/cli | GnuParser.java |   |
| jbang       |                                      |                |   |

* Base
** Types
- Can’t pass a primitive type by reference

*** Integers
- are signed, positive and negative values

**** byte
- smallest integer type
- –128 to 127

#+begin_src java
byte b, c;
#+end_src

**** short
- range from –32,768 to 32,767

#+begin_src java
short s;
short t;
#+end_src
**** int
- range from –2,147,483,648 to 2,147,483,647
- byte and short values in expressions are promoted to int when evaluated
#+begin_src java
int x = 0b1010; // integer binary
int y = 123_456_789;
int y = 123___456___789;
#+end_src
**** long
*** Floating
- real numbers
- IEEE–754
- defaults to double precision
- supports hexadecimal floating-point

#+begin_src java
0x12.2P2 // hexadecimal fp
double num = 9_423_497_862.0;
#+end_src

**** float
- 1.4e–045 to 3.4e+038
- single-precision
- takes half as much space as double precision
- imprecise when the values are either very large or very small

#+begin_src java
float hightemp, lowtemp;
#+end_src
**** double
- 4.9e–324 to 1.8e+308

#+begin_src java
// Compute the area of a circle.
class Area {
    public static void main(String[] args) {
        double pi, r, a;
        r = 10.8; // radius of circle
        pi = 3.1416; // pi, approximately
        a = pi * r * r; // compute area
        System.out.println("Area of circle is " + a);
    }
}
#+end_src
*** Strings
#+begin_src java
"Hello World"
"two\nlines"
" \"This is in quotes\""
"foo" + " bar" // "foo bar"
#+end_src

**** String Builder
- java.lang.StringBuilder
- gradually build a string

#+begin_src java
new StringBuilder()
#+end_src

*.append(string)*
#+begin_src java
new StringBuilder("meh").append(" foo").append(" bar").toString()
#+end_src

*.charAt(int)*

*.delete(from, to)*

*.insert(from, v)*

*.length()*

*.replace(from, to, s)*

*.reverse()*

*.setCharAt(i,c)*

*.toString()*

**** String Buffers
- same as Builder
- thread-safe

*** Characters
- store characters
- range of 0 to 65,535
- able to manipulate with the integer operators

#+begin_src java
'\u0061' // ISO-Latin-1 'a'
'\ua432 ' // ꐲ - Japanese Katakana character.

// Demonstrate char data type.
class CharDemo {
    public static void main(String[] args) {
        char ch1, ch2;
        ch1 = 88; // code for X
        ch2 = 'Y';
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
    }
}
#+end_src

*** Boolean
- true
- false
- wont convert into any numerical representation

#+begin_src java
// Demonstrate boolean values.
class BoolTest {
    public static void main(String[] args) {
        boolean b;
        b = false;
        System.out.println("b is " + b);
        b = true;
        System.out.println("b is " + b);
        // a boolean value can control the if statement
        if(b) System.out.println("This is executed.");
        b = false;
        if(b) System.out.println("This is not executed.");
        // outcome of a relational operator is a boolean value
        System.out.println("10 > 9 is " + (10 > 9));

    }
}
#+end_src
** Collection Types
*** Arrays
*new*
#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
int[] myNum = {10, 20, 30, 40};
#+end_src

*acessing*

#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars[0]);
#+end_src

*change value*

#+begin_src java
cars[0] = "Opel";
#+end_src

*length*

#+begin_src java
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
System.out.println(cars.length);
#+end_src

*asList*
*fill*
*copyOf*
*compare*
*sort*
*** Lists
*add*
Add item to last position

#+begin_src java
List<String> meh = list.add("foo");
#+end_src

*addAll*
Merge lists

#+begin_src java
List<String> meh = list.addAll(anotherList);
#+end_src
*** HashSet
- unique elements on list

#+begin_src java
new HashSet<>(listedList)
#+end_src

** Packages
- must be stored in sub-directories represented in the dot path
- A class declared in a source file with no package declaration belongs to the anonymous default package

#+begin_src java
import p.C;
import p.*;
import static p.C.*;

package org.foo.bar
#+end_src

*importing*
- optional, as oposing fully qualified name usage.

- fully qualified
#+begin_src java
class MyDate extends java.util.Date {
...
}
#+end_src

#+begin_src java
import java.util.Date;
import java.io.*;

class MyDate extends Date {
}
#+end_src

** Classes
*** Member Access
*** Local Classes
A local class is declared locally within a block of Java code, rather than as a
member of a class.
#+begin_src java
    // This method creates and returns an Enumeration object
public java.util.Enumeration enumerate() {
    // Here's the definition of Enumerator as a local class
    class Enumerator implements java.util.Enumeration {
        Linkable current;

        public Enumerator() {
            current = head;
        }

        public boolean hasMoreElements() {
            return (current != null);
        }

        public Object nextElement() {
            if (current == null)
                throw new java.util.NoSuchElementException();
            Object value = current;
            current = current.getNext();
            return value;
        }
    }
    // Now return an instance of the Enumerator class defined directly above
    return new Enumerator();
}
#+end_src

** Modifiers
*** final
#+begin_src sh
final int
#+end_src
On methods prevent it to be overriden
#+begin_src sh
final void meth() {
System.out.println("This is a final method.");
}
#+end_src

** Variables
- an identifier, a type, and an optional initialize
- has a scope, which defines their visibility, and lifetime
- must be declared before being used

#+begin_src java
int a, b, c;
int d = 3, e, f = 5;
byte z = 22;
double pi = 3.14159;
char x = 'x';
#+end_src
** Classes
*** Access Control
**** Public
- can be accessed by any other code
- default access
**** Private
- can only be accessed by other members of its class.
**** Protected
- applies only when inheritance is involved
*** Static
- can only directly call other static methods of their class
- can only directly access static variables of their class.
- cannot refer to this or super
- are, essentially, global variables
*** Final
- prevents its contents from being modified, making it, essentially, a constant.
- you must initialize a final field when it is declared.
- can give it a value when it is declared or assign it a value within a constructor


- prevents methods overriding
- sometimes provide a performance enhancement (inline calls)

#+begin_src java
class A {
	final void meth() {
		System.out.println("This is a final method.");
	}
}
class B extends A {
	void meth() { // ERROR! Can't override.
		System.out.println("Illegal!");
	}
}
#+end_src

- prevents inheritance

#+begin_src java
final class A {
	//...
}
// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
	//...
}
#+end_src
*** Seal
*** Inheritance
- inherits all from super object
- single-inheritance
- private on superclass elements are not inherited by subclasses

#+begin_src java
class A {
	int i, j;
	void showij() {
		System.out.println("i and j: " + i + " " + j);
	}
}
// Create a subclass by extending class A.
class B extends A {
	int k;
	void showk() {
		System.out.println("k: " + k);
	}
	void sum() {
		System.out.println("i+j+k: " + (i+j+k));
	}
}
#+end_src
*** super
- must always be the first statement executed inside a subclass’ constructor.
*** Abstract Classes
Defines a superclass that declares the structure of a given abstraction without
providing a complete implementation of every method.

#+begin_src java
// A Simple demonstration of abstract.
abstract class A {
  abstract void callme();
  // concrete methods are still allowed in abstract classes
  void callmetoo() { System.out.println("This is a concrete method."); }
}

class B extends A {
  void callme() { System.out.println("B's implementation of callme."); }
}

class AbstractDemo {
  public static void main(String[] args) {
    B b = new B();
    b.callme();
    b.callmetoo();
  }
}
#+end_src
*** useful methods to implement
#+begin_src java
equals()
hashCode()
toString()
#+end_src
** Interfaces
- Cannot mantain state
- JDK 7: an interface could not define any implementation whatsoever.
- JDK 8: adds a default implementation to an interface method.
- JDK 8: adds static interface methods
- JDK 9: includes private methods
- a class must provide the complete set of methods required by the interface. 
- designed to support dynamic method resolution at run time.
- one class can implement any number of interfaces.

#+begin_src java
interface Callback {
    void callback(int param);
}
#+end_src

- variables are implicitly final and static
- methods and variables are implicitly public.
- interface's method must be public

#+begin_src java
class Client implements Callback { // interface's method must be public
// Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }
}
#+end_src

#+begin_src java
class Client implements Callback {
    // Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }

    void nonIfaceMeth() {
        System.out.println("Classes that implement interfaces " + "may also define other members, too.");
    }
}
#+end_src

Interface as variable reference
- An interface reference variable has knowledge only of the methods declared by its interface declaration.

#+begin_src java
class TestIface {
    public static void main(String[] args) {
        Callback c = new Client();
        c.callback(42);
    }
}
#+end_src

Partial Implementations
- not fully implement the methods required by that interface, then that class must be declared as abstract.
- Any class that inherits Incomplete must implement callback( ) or be declared abstract itself.

#+begin_src java
abstract class Incomplete implements Callback {
    int a, b;

    void show() {
        System.out.println(a + " " + b);
    }
    // ...
}
#+end_src

Nested Interfaces

- member interfaces
- can be declared as public, private, or protected.
- differs from a top-level interface, which must either be declared as public or use the default access level


#+begin_src java
class A {
    // this is a nested interface
    public interface NestedIF {
        boolean isNotNegative(int x);
    }
}

// B implements the nested interface.
class B implements A.NestedIF {
    public boolean isNotNegative(int x) {
        return x < 0 ? false : true;
    }
}

class NestedIFDemo {
    public static void main(String[] args) {
        // use a nested interface reference
        A.NestedIF nif = new B();
        if (nif.isNotNegative(10))
            System.out.println("10 is not negative");
        if (nif.isNotNegative(-12))
            System.out.println("this won't be displayed");
    }
}
#+end_src

Extending interfaces

- must provide implementations for all methods required by the interface inheritance chain

#+begin_src java
// One interface can extend another.
interface A {
    void meth1();
    void meth2();
}

// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A {
    void meth3();
}

// This class must implement all of A and B
class MyClass implements B {
    public void meth1() {
        System.out.println("Implement meth1().");
    }

    public void meth2() {
        System.out.println("Implement meth2().");
    }

    public void meth3() {
        System.out.println("Implement meth3().");
    }
}

class IFExtend {
    public static void main(String[] args) {
        MyClass ob = new MyClass();
        ob.meth1();
        ob.meth2();
        ob.meth3();
    }
}
#+end_src

Default method

- extension method
- provide a body, rather than being abstract.
- supplies an implementation that will be used if no other implementation is explicitly provided
- JDK 8

#+begin_src java
interface IntStack {
    void push(int item); // store an item
    int pop(); // retrieve an item
    // Because clear( ) has a default, it need not be
    // implemented by a preexisting class that uses IntStack.
    default void clear() {
        System.out.println("clear() not implemented.");
    }
}
#+end_src

- refers to a default implementation in an inherited interface by using super.

#+begin_src
Alpha.super.reset();
#+end_src

*Interface static Methods*

- no implementation of the interface is necessary, and no instance of the interface is required, in order to call a static method.

#+begin_src java
public interface MyIF {
    // This is a "normal" interface method declaration.
    // It does NOT define a default implementation.
    int getNumber();

    // This is a default method. Notice that it provides
    // a default implementation.
    default String getString() {
        return "Default String";
    }

    // This is a static interface method.
    static int getDefaultNumber() {
        return 0;
    }
}

// ...
int defNum = MyIF.getDefaultNumber();
#+end_src

*Private Interface Methods*

- only called by a default method or another private method defined by the same interface.
- cannot be used by code outside the interface in which it is defined, including subinterfaces
- used as a shared common piece of code

#+begin_src java
// Another version of IntStack that has a private interface
// method that is used by two default methods.
interface IntStack {
    void push(int item); // store an item

    int pop();
    // retrieve an item

    // A default method that returns an array that contains
    // the top n elements on the stack.
    default int[] popNElements(int n) {
        // Return the requested elements.
        return getElements(n);
    }

    // A default method that returns an array that contains
    // the next n elements on the stack after skipping elements.
    default int[] skipAndPopNElements(int skip, int n) {
        // Skip the specified number of elements.
        getElements(skip);
        // Return the requested elements.
        return getElements(n);
    }

    // A private method that returns an array containing
    // the top n elements on the stack
    private int[] getElements(int n) {
        int[] elements = new int[n];
        for (int i = 0; i < n; i++)
            elements[i] = pop();
        return elements;
    }
}
#+end_src
** Exceptions
- can be generated by the Java run-time system
- can be manually generated by your code
- all exception types are subclasses of the built-in class Throwable

#+begin_src java
try {
// block of code to monitor for errors
}
catch (ExceptionType1 exOb) {
// exception handler for ExceptionType1
}
catch (ExceptionType2 exOb) {
// exception handler for ExceptionType2
}
// ...
finally {
// block of code to be executed after try block ends
}
#+end_src

*Custom Exceptions*

#+begin_src java
// This program creates a custom exception type.
class MyException extends Exception {
  private int detail;
  MyException(int a) { detail = a; }
  public String toString() { return "MyException[" + detail + "]"; }
}
class ExceptionDemo {
  static void compute(int a) throws MyException {
    System.out.println("Called compute(" + a + ")");
    if (a > 10)
      throw new MyException(a);
    System.out.println("Normal exit");
  }
  public static void main(String[] args) {
    try {
      compute(1);
      compute(20);
    } catch (MyException e) {
      System.out.println("Caught " + e);
    }
  }
}
#+end_src

*Chained Exceptions*

Allows you to associate another exception with an exception. This second
exception describes the cause of the first exception.

#+begin_src java
Throwable(Throwable causeExc)
Throwable(String msg, Throwable causeExc)
#+end_src

#+begin_src java
Throwable getCause( )
Throwable initCause(Throwable causeExc)
#+end_src

- getCause( ) method returns the exception that underlies the current exception or null
- initCause( ) method associates causeExc with the invoking exception and returns a reference to the exception.
- can call initCause( ) only once for each exception object

#+begin_src java
// Demonstrate exception chaining.
class ChainExcDemo {
  static void demoproc() {
    // create an exception
    NullPointerException e = new NullPointerException("top layer");
    // add a cause
    e.initCause(new ArithmeticException("cause"));
    throw e;
  }

  public static void main(String[] args) {
    try {
      demoproc();
    } catch (NullPointerException e) {
      // display top level exception
      System.out.println("Caught: " + e);
      // display cause exception
      System.out.println("Original cause: " + e.getCause());
    }
  }
}
#+end_src

*try-with-resources*

*multi-catch*
- allows two or more exceptions to be caught by the same catch clause.
- use a single catch clause to handle all of the exceptions without code duplication
- multi-catch parameters are implicitly final

#+begin_src java
 // Demonstrate the multi-catch feature.
class MultiCatch {
  public static void main(String[] args) {
    int a = 10, b = 0;
    int[] vals = {1, 2, 3};
    try {
      int result = a / b; // generate an ArithmeticException
      //
      vals[10] = 19; // generate an ArrayIndexOutOfBoundsException
      // This catch clause catches both exceptions.
    } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
      System.out.println("Exception caught: " + e);
    }
    System.out.println("After multi-catch.");
  }
}
#+end_src

*rethrow*

*try/catch*
- allows you to fix the error
- prevents the program from automatically terminating
- well-constructed catch clauses should be to resolve the exceptional condition and then continue on as if the error had never happened.
#+begin_src java
class Exc2 {
  public static void main(String[] args) {
    int d, a;
    try { // monitor a block of code.
      d = 0;
      a = 42 / d;
      System.out.println("This will not be printed.");
    } catch (ArithmeticException e) { // catch divide-by-zero error
      System.out.println("Division by zero.");
    }
    Chapter 10 Exception Handling 231 System.out.println(
        "After catch statement.");
  }
}
#+end_src

*throw*

*throws*

*finally*

*Exception class*
- for exceptional conditions that user programs should catch.
- for class that you will subclass to create your own custom exception types.

*Error class*
- indicates errors having to do with the run-time environment
- exceptions that are not expected to be caught under normal circumstances by your program.

*Nested Try*

#+begin_src java
class NestTry {
  public static void main(String[] args) {
    try {
      int a = args.length;
      int b = 42 / a;
      System.out.println("a = " + a);
      try {
        if (a == 1)
          a = a / (a - a);
        if (a == 2) {
          int[] c = {1};
          c[42] = 99;
        }
      } catch (ArrayIndexOutOfBoundsException e) {
        System.out.println("Array index out-of-bounds: " + e);
      }
    } catch (ArithmeticException e) {
      System.out.println("Divide by 0: " + e);
    }
  }
}
#+end_src

** Enumerations
- specifies the only values that a data type can legally have.
- can have constructors, methods, and instance variables.
- can have constructors, add instance variables and methods, and even implement interfaces
- inherits from java.lang.Enum

#+begin_src java
enum Apple {
    Jonathan, GoldenDel, RedDel, Winesap, Cortland
}

class EnumDemo {
  public static void main(String[] args) {
    Apple ap;
    ap = Apple.RedDel;
    // Output an enum value.
    System.out.println("Value of ap: " + ap);
    System.out.println();
    ap = Apple.GoldenDel;
    // Compare two enum values.
    if (ap == Apple.GoldenDel)
      System.out.println("ap contains GoldenDel.\n");
    // Use an enum to control a switch statement.
    switch (ap) {
    case Jonathan:
      System.out.println("Jonathan is red.");
      break;
    case GoldenDel:
      System.out.println("Golden Delicious is yellow.");
      break;
    case RedDel:
      System.out.println("Red Delicious is red.");
      break;
    case Winesap:
      System.out.println("Winesap is red.");
      break;
    case Cortland:
      System.out.println("Cortland is red.");
      break;
    }
  }
}
#+end_src

*values*
Returns an array that contains a list of the enumeration constants

#+begin_src java
public static enum-type [ ] values( )
#+end_src

*valueOf*

Returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
public static enum-type valueOf(String str )
#+end_src

returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
enum Apple { Jonathan, GoldenDel, RedDel, Winesap, Cortland }
class EnumDemo2 {
  public static void main(String[] args) {
    Apple ap;
    System.out.println("Here are all Apple constants:");
    // use values()
    Apple[] allapples = Apple.values();
    for (Apple a : allapples)
      System.out.println(a);
    System.out.println();
    // use valueOf()
    ap = Apple.valueOf("Winesap");
    System.out.println("ap contains " + ap);
  }
}
#+end_src

*constructor*

#+begin_src java
// Use an enum constructor, instance variable, and method.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel(12),
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  int getPrice() { return price; }
}

class EnumDemo3 {
  public static void main(String[] args) {
    Apple ap;

    System.out.println("Winesap costs " + Apple.Winesap.getPrice() +  " cents.\n");

    System.out.println("All apple prices:");
    for (Apple a : Apple.values())
      System.out.println(a + " costs " + a.getPrice() + " cents.");
  }
}
#+end_src

- multiple constructors

#+begin_src java
// Use an enum constructor.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel,
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  // Overloaded constructor
  Apple() { price = -1; }
  int getPrice() { return price; }
}
#+end_src

*ordinal*

indicates an enumeration constant’s position in the list of constants.

#+begin_src java
ap.Winesap.ordinal() // 3
#+end_src

*compareTo*

#+begin_src java
ap.Winesap.compareTo(ap.Cortland) // -1
#+end_src

*equals*

#+begin_src java
ap.Winesap.equals(ap.Cortland) // false
 m.Winesap == m.Cortland // false
#+end_src
** Streams
An abstraction that either produces or consumes information

- must import java.io

*** PrintStream

#+begin_src java
void write(int byteval)
#+end_src

#+begin_src java
class WriteDemo {
public static void main(String[] args) {
int b;
b = 'A';
System.out.write(b);
System.out.write('\n');
}
}
#+end_src

*** OutputStream
*** FileInputStream
#+begin_src java
FileInputStream(String fileName) throws FileNotFoundException
#+end_src

#+begin_src java
import java.io.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

class ShowFile {
  public static void main(String[] args) {
    int i;
    FileInputStream fin = null;
    // First, confirm that a filename has been specified.
    if (args.length != 1) {
      System.out.println("Usage: ShowFile filename");
      return;
    }
    // The following code opens a file, reads characters until EOF
    // is encountered, and then closes the file via a finally block.
    try {
      fin = new FileInputStream(args[0]);
      do {
        i = fin.read();
        if (i != -1)
          System.out.print((char) i);
      } while (i != -1);

    } catch (FileNotFoundException e) {
      System.out.println("File Not Found.");
    } catch (IOException e) {
      System.out.println("An I/O Error Occurred");
    } finally {
      // Close file in all cases.
      try {
        if (fin != null)
          fin.close();
      } catch (IOException e) {
        System.out.println("Error Closing File");
      }
    }
  }
}
#+end_src
- JDK 9: , it is also possible for the resource specification of the try to consist of a variable
  that has been declared and initialized earlier in the program. However, that variable must be effectively final,
  which means that it has not been assigned a new value after being given its initial value.


#+begin_src java
import java.io.*;

class ShowFile {
  public static void main(String[] args) {
    int i;
    // First, confirm that a filename has been specified.
    if (args.length != 1) {
      System.out.println("Usage: ShowFile filename");
      return;
    }
    // The following code uses a try-with-resources statement to open
    // a file and then automatically close it when the try block is left.
    try (FileInputStream fin = new FileInputStream(args[0])) {
      do {
        i = fin.read();
        if (i != -1)
          System.out.print((char) i);
      } while (i != -1);
    } catch (FileNotFoundException e) {
      System.out.println("File Not Found.");
    } catch (IOException e) {
      System.out.println("An I/O Error Occurred");
    }
  }
}
#+end_src

*** FileOutputStream
#+begin_src java
FileOutputStream(String fileName) throws FileNotFoundException
#+end_src

*** close()
Closes a file releases the system resources allocated to the file, allowing them to be used by another file.
- java.lang. AutoCloseable interface

#+begin_src java
void close( ) throws IOException
#+end_src

** IO
*** BufferedReader

*read()*
Reads a character from the input stream and returns it as an integer value

#+begin_src java
int read( ) throws IOException
#+end_src

#+begin_src java
import java.io.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

class BRRead {
  public static void main(String[] args) throws IOException {
    char c;
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in, System.console().charset()));

    System.out.println("Enter characters, 'q' to quit.");

    do {
      c = (char)br.read();
      System.out.println(c);
    } while (c != 'q');
  }
}
#+end_src


*readLine()*

Reads a string from the keyboard

#+begin_src java
String readLine( ) throws IOException
#+end_src

#+begin_src java
import java.io.*;
class BRReadLines {
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in, System.console().charset()));
    String str;

    System.out.println("Enter lines of text.");
    System.out.println("Enter 'stop' to quit.");

    do {
      str = br.readLine();
      System.out.println(str);
    } while (!str.equals("stop"));
  }
}
#+end_src

#+begin_src java
import java.io.*;
class TinyEdit {
  public static void main(String[] args) throws IOException {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in, System.console().charset()));
    String[] str = new String[100];

    System.out.println("Enter lines of text.");
    System.out.println("Enter 'stop' to quit.");

    for (int i = 0; i < 100; i++) {
      str[i] = br.readLine();
      if (str[i].equals("stop"))
        break;
    }

    System.out.println("\nHere is your file:");

    for (int i = 0; i < 100; i++) {
      if (str[i].equals("stop"))
        break;
      System.out.println(str[i]);
    }
  }
}
#+end_src
*** PrintWriter
- for real-word its the recommended method of writing to the console
- makes real-world applications easier to internationalize.
- If flushingOn is true, flushing automatically takes place.
- If false, flushing is not automatic.

#+begin_src java
PrintWriter(OutputStream outputStream, boolean flushingOn)
#+end_src

#+begin_src java
import java.io.*;

public class PrintWriterDemo {
  public static void main(String[] args) {
    PrintWriter pw = new PrintWriter(System.out, true);
    pw.println("This is a string");
    int i = -7;
    pw.println(i);
    double d = 4.5e-7;
    pw.println(d);
  }
}
#+end_src

#+begin_src java
PrintWriter printWriter = new PrintWriter("test.txt");
printWriter.print("Test PrintWriter Line 1 ");
printWriter.print("Test PrintWriter Line 2 ");
printWriter.print("Test PrintWriter Line 3");
printWriter.close();
#+end_src

** Annotations
Enables to embed supplemental information into a source file.

- java.lang.annotation
- @ declares an  annotation type to the compiler
- annotation can be annotated.
- JDK 8: adds the ability to annotate type use
-
#+begin_src java
// A simple annotation type.
@interface MyAnno {
    String str();
    int val();
}
#+end_src

*Meta Annotations*

*Retention Policies*
- determines at what point an annotation is discarded: SOURCE, CLASS, and RUNTIME
- SOURCE: retained only in the source file and is discarded during compilation.
- CLASS: stored in the .class file during compilation. However, it is not available through the JVM during run time.
- RUNTIME: stored in the .class file during compilation and is available through the JVM during run time. Thus, RUNTIME retention
offers the greatest annotation persistence.

#+begin_src java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str();
    int val();
}
#+end_src

*getAnnotation*
- returns a reference to the annotation
- returns null if the annotation is not found

#+begin_src java
<A extends Annotation> getAnnotation(Class<A> annoType)
#+end_src

#+begin_src java
import java.lang.annotation.*;
import java.lang.reflect.*;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str();
  int val();
}

class Meta {
  // myMeth now has two arguments.
  @MyAnno(str = "Two Parameters", val = 19)
  public static void myMeth(String str, int i) {
    Meta ob = new Meta();
    try {
      Class<?> c = ob.getClass();
      // Here, the parameter types are specified.
      Method m = c.getMethod("myMeth", String.class, int.class);
      MyAnno anno = m.getAnnotation(MyAnno.class);
      System.out.println(anno.str() + " " + anno.val());
    } catch (NoSuchMethodException exc) {
      System.out.println("Method Not Found.");
    }
  }
  public static void main(String[] args) { myMeth("test", 10); }
}
#+end_src

*getAnnotations*

#+begin_src java
Annotation[ ] getAnnotations( )
#+end_src

#+begin_src java
Meta2 ob = new Meta2();
Annotation[] annos = ob.getClass().getAnnotations();

Method m = ob.getClass( ).getMethod("myMeth");
annos = m.getAnnotations();
#+end_src

*Default Values*
Default values that will be used if no value is specified when the annotation is applied

- A default value is specified by adding a default clause to a member’s declaration.

#+begin_src java
type member( ) default value ;
#+end_src

#+begin_src java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str() default "Testing";
    int val() default 9000;
}

@MyAnno() // both str and val default
@MyAnno(str = "some string") // val defaults
@MyAnno(val = 100) // str defaults
@MyAnno(str = "Testing", val = 100) // no defaults
#+end_src

#+begin_src java

#+end_src
*Marker Annotations*

** Generics
Creates classes, interfaces, and methods that will work in a type-safe manner
with various kinds of data

- Parameterized types
- Any valid identifier could have been used, but T is traditional.
- Recommended that type parameter names be single-character capital letters (T,V,E)
- In essence, through generics, run-time errors are converted into compile-time errors

|        |                                                |
|--------+------------------------------------------------|
| JDK 10 | Cannot use var as the name of a type parameter |
|        |                                                |

#+begin_src java
class-name<type-arg-list > var-name = new class-name<type-arg-list >(cons-arg-list);
#+end_src

- as constructor param
#+begin_src java
Gen(T o) {
    ob = o;
}
#+end_src

- as a method return type

#+begin_src java
T getOb() {
    return ob;
}
#+end_src

- the type argument passed to the type parameter must be a reference type
#+begin_src java
Gen<Integer> intOb = new Gen<Integer>(53); // Correct!
Gen<int> intOb = new Gen<int>(53); // Error, can't use primitive type
#+end_src

#+begin_src java
class Gen<T> {
  T ob;

  Gen(T o) {
    ob = o;
  }

  T getOb() {
    return ob;
  }

  void showType() {
    System.out.println("Type of T is " + ob.getClass().getName());
  }
}

public static void main(String[] args) {
  Gen<Integer> iOb;

  iOb = new Gen<Integer>(88);

  iOb.showType();

  int v = iOb.getOb();

  Gen<String> strOb = new Gen<String>("Generics Test");

  strOb.showType();

  String str = strOb.getOb();
}
#+end_src

*more than one type parameter*

#+begin_src java
class TwoGen<T, V> {
    T ob1;
    V ob2;

    TwoGen(T o1, V o2) {
        ob1 = o1;
        ob2 = o2;
    }

    void showTypes() {
        System.out.println("Type of T is " + ob1.getClass().getName());
        System.out.println("Type of V is " + ob2.getClass().getName());
    }

    T getOb1() {
        return ob1;
    }

    V getOb2() {
        return ob2;
    }
}

class SimpGen {
    public static void main(String[] args) {
        TwoGen<Integer, String> tgObj = new TwoGen<Integer, String>(88, "Generics");

        tgObj.showTypes();

        int v = tgObj.getOb1();
        System.out.println("value: " + v);

        String str = tgObj.getOb2();
        System.out.println("value: " + str);
    }
}
#+end_src

*Bounded Types*
Limit the types that can be passed to a type parameter.
- can also use a type intersection in a cast.

#+begin_src java
class Stats<T extends Number> {
  T[] nums;

  Stats(T[] o) { nums = o; }

  double average() {
    double sum = 0.0;
    for (int i = 0; i < nums.length; i++)
      sum += nums[i].doubleValue();
    return sum / nums.length;
  }
}

// multiple bounded types
class Gen<T extends MyClass & MyInterface> {}
#+end_src

*Wildcard Arguments*
The wildcard argument is specified by the ?, and it represents an unknown type.

#+begin_src java
// Notice the use of the wildcard.
boolean isSameAvg(Stats<?> ob) {
  if(average() == ob.average())
    return true;

  return false;
}
#+end_src

*Bounded Wildcards*
- match any type as long as it is that type, or a class derived from it.

upper bound
#+begin_src java
<? extends superclass>
#+end_src

lower bound
- only classes that are superclasses of subclass are acceptable arguments. This is an inclusive clause.

#+begin_src java
<? super subclass>
#+end_src

#+begin_src java
static void showXYZ(Coords<? extends ThreeD> c) {
  System.out.println("X Y Z Coordinates:");
  for(int i=0; i < c.coords.length; i++)
    System.out.println(c.coords[i].x + " " +
                       c.coords[i].y + " " +
                       c.coords[i].z);
  System.out.println();
}
#+end_src

*Generic method*
- Declare a generic method that uses one or more type parameters of its own.
- Creates a generic method that is enclosed within a  non-generic class.
- can be either static or non-static.

#+begin_src java
static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] y) {
        for(int i=0; i < y.length; i++)
    if(x.equals(y[i])) return true;

  return false;
}

    // Use isIn() on Integers.
    Integer[] nums = { 1, 2, 3, 4, 5 };

    if(isIn(2, nums))
      System.out.println("2 is in nums");

    if(!isIn(7, nums))
      System.out.println("7 is not in nums");
#+end_src

*Generic constructors*
- non-generic classes can have generic constructor

#+begin_src java
// Use a generic constructor.
class GenCons {
  private double val;

  <T extends Number> GenCons(T arg) {
    val = arg.doubleValue();
  }

  void showVal() {
    System.out.println("val: " + val);
  }
}

class GenConsDemo {
  public static void main(String[] args) {

    GenCons test = new GenCons(100);
    GenCons test2 = new GenCons(123.5F);

    test.showVal();
    test2.showVal();
  }
}
#+end_src

*Generic interfaces*
- if a class implements a generic interface, then that class must also be generic.

#+begin_src java
interface interface-name<type-param-list> { // …
#+end_src

#+begin_src java
interface MinMax<T extends Comparable<T>> {
  T min();
  T max();
}

class MyClass<T extends Comparable<T>> implements MinMax<T> {
  T[] vals;

  MyClass(T[] o) { vals = o; }

  // Return the minimum value in vals.
  public T min() {
    T v = vals[0];

    for(int i=1; i < vals.length; i++)
      if(vals[i].compareTo(v) < 0) v = vals[i];

    return v;
  }

  // Return the maximum value in vals.
  public T max() {
    T v = vals[0];

    for(int i=1; i < vals.length; i++)
      if(vals[i].compareTo(v) > 0) v = vals[i];

    return v;
  }
}

class GenIFDemo {
  public static void main(String[] args) {
    Integer[] inums = {3, 6, 2, 8, 6 };
    Character[] chs = {'b', 'r', 'p', 'w' };

    MyClass<Integer> iob = new MyClass<Integer>(inums);
    MyClass<Character> cob = new MyClass<Character>(chs);

    System.out.println("Max value in inums: " + iob.max());
    System.out.println("Min value in inums: " + iob.min());
    System.out.println("Max value in chs: " + cob.max());
    System.out.println("Min value in chs: " + cob.min());
  }
}
#+end_src

*Raw Code*

#+begin_src java
// Demonstrate a raw type.
class Gen<T> {

  T ob; // declare an object of type T

  // Pass the constructor a reference to
  // an object of type T.
  Gen(T o) {
    ob = o;
  }

  // Return ob.
  T getOb() {
    return ob;
  }
}

// Demonstrate raw type.
class RawDemo {
  public static void main(String[] args) {

    // Create a Gen object for Integers.
    Gen<Integer> iOb = new Gen<Integer>(88);

    // Create a Gen object for Strings.
    Gen<String> strOb = new Gen<String>("Generics Test");

    // Create a raw-type Gen object and give it
    // a Double value.
    Gen raw = new Gen(Double.valueOf(98.6));

    // Cast here is necessary because type is unknown.
    double d = (Double) raw.getOb();
    System.out.println("value: " + d);

    // The use of a raw type can lead to run-time
    // exceptions. Here are some examples.

    // The following cast causes a run-time error!
//    int i = (Integer) raw.getOb(); // run-time error

    // This assignment overrides type safety.
    strOb = raw; // OK, but potentially wrong
//    String str = strOb.getOb(); // run-time error

    // This assignment also overrides type safety.
    raw = iOb; // OK, but potentially wrong
//    d = (Double) raw.getOb(); // run-time error
  }
}
#+end_src

- A generic class can act as a superclass or be a subclass.
- Any type arguments needed by a generic superclass must be passed up the hierarchy by all subclasses

** Lambda
- two constructs: the lambda expression, itself, the functional interface.
- anonymous method
- A functional interface is an interface that contains one and only one abstract method.
- at times referred as SAM type, where SAM stands for Single Abstract Method
- lambda operator, arrow operator
- −> can be verbalized as “becomes” or “goes to.”

#+begin_src java
() -> 123.45
() -> Math.random() * 100
#+end_src

- type and number of the lambda expression’s parameters must be compatible  with the method’s parameters
- return types must be compatible
- exceptions thrown by the lambda expression must be acceptable to the method.

#+begin_src java
interface MyNumber {
  double getValue();
}
MyNumber myNum = () -> 123.45;
myNum.getValue() // 123.45

interface SumMe {
    double Summing(Double x,Double y);
}

SumMe summing = (x,y) -> x + y; // ==> $Lambda$21/0x0000000800c0b408@1ddc4ec2
summing.Summing(1.2,1.2) // ==> 2.4
#+end_src

** Autoboxing
** Type Wrappers
- classes that encapsulate a primitive type within an object.

*Character*
- JDK 9: the Character constructor was deprecated,
- JDK 16: it has been deprecated for removal.
 - Its recommended that you use the static method valueOf( ) to obtain a Character object.

#+begin_src java
static Character valueOf(char ch)
#+end_src

Get value contained in a Character object,
#+begin_src java
char charValue( )
#+end_src

*Boolean*

#+begin_src java
static Boolean valueOf(boolean boolValue)
static Boolean valueOf(String boolString)
#+end_src
#+begin_src java
boolean booleanValue( )
#+end_src

*numeric*

#+begin_src java
static Integer valueOf(int val)
static Integer valueOf(String valStr) throws NumberFormatException
#+end_src

* Standard Library
** java.lang
*** System
#+begin_src java
String home = System.getProperty("user.home");
#+end_src
*** Annotation
*** Class<T>
- encapsulates the run-time state of a class or interface.

*Class<?>*
- ? wildcard
- JDK16: includes methods that support records.
- JDK 17: includes methods that support sealed classes and interfaces.
- JDK 11: provides three methods that relate to a nest - a group of classes and/or interfaces nested within an outer class or interface.
Class is a parameterizable class, the syntax Class<T> where T is a type.
Class<?>, declares a Class object which can be of any type (? is a wildcard).
The Class type is a type that contains meta-information about a class.


In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.

#+begin_src java
Meta3 ob = new Meta3();
Class<?> c = ob.getClass();
Method m = c.getMethod("myMeth");
MyAnno anno = m.getAnnotation(MyAnno.class);
System.out.println(anno.str() + " " + anno.val());
#+end_src

#+begin_src java
package com.w3spoint;

public class TestClass {
	public void display(String message){
		System.out.println(message);
	}
}

// ----

package com.w3spoint;

import java.lang.reflect.Method;

public class ReflectionTest {
	public static void main(String args[]){
		try {
			Class c=Class.forName("com.w3spoint.TestClass");
			Method method = c.getMethod("display", String.class);
			System.out.println("Return Type: " + method.getReturnType());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
#+end_src

#+begin_src java
class X {
  int a;
  float b;
}

class Y extends X {
  double c;
}

class RTTI {
public
  static void main(String[] args) {
    X x = new X();
    Y y = new Y();
    Class < ? > clObj;
    clObj = x.getClass(); // get Class reference
    System.out.println("x is object of type: " + clObj.getName());
    clObj = y.getClass(); // get Class reference
    System.out.println("y is object of type: " + clObj.getName());
    clObj = clObj.getSuperclass();
    System.out.println("y's superclass is " + clObj.getName());
  }
}
#+end_src

** java.lang.reflect
*** AnnotatedElement

- Interface
- java.lang.reflect

#+begin_src java
Annotation[ ] getDeclaredAnnotations( )
#+end_src

#+begin_src java
Annotation[ ] getAnnotations( )
#+end_src


#+begin_src java
<A extends Annotation> getAnnotation(Class<A> annoType)
#+end_src

#+begin_src java
default boolean isAnnotationPresent(Class<? extends Annotation> annoType)
#+end_src

#+begin_src java
getDeclaredAnnotation( )
getAnnotationsByType()
getDeclaredAnnotationsByType( )
#+end_src
** java.util.collection
*toArray(IntFunction)*

#+begin_src java
// Java 11
List<String> list = Arrays.asList("foo","bar","baz");
String[] array = list.toArray(String[]::new);

// The above is equivalent to:
String[] array2 = list.toArray(new String[0]);
#+end_src
** java.nio
*** file
*FileSystems*
#+begin_src java
  Path start = FileSystems.getDefault().getPath(source);
#+end_src
*** Path
*of*
- JDK11: preferable over early get

#+begin_src java
Path.of("/path/of/folder", "filename") // "/path/of/folder/filename"
#+end_src

get
#+begin_src java
Path filepath = Paths.get(System.getProperty("user.home"), "data", "foo.txt");
#+end_src
** System

* Commands
** java
launch a Java application

*-jar*

#+begin_src java
java -jar target/taco-cloud-0.0.1-SNAPSHOT.jar
#+end_src

*-cp*

#+begin_src shell
java -cp target/zae-1.0-SNAPSHOT.jar org.easbarba.zae.App
#+end_src

*-m or --module module[/mainclass]*

*--list-modules*

*cp*

#+begin_src shell
java -cp target/cdeps-0.1.0.jar clojure.main -m com.tomekw.cdeps.core
#+end_src

** jlink
#+begin_src sh
jlink --add-modules java.base --output javao
#+end_src
** jar
#+begin_src shell
jar vcf p.jar c
#+end_src
** javac
Read Java declarations and compile them into class files
** javadoc
** javap
** jshell

* Utilities
- jlink
- jpackage
  -
* Environment Variables
*JAVA_HOME*
*JDK_JAVA_OPTIONS*

* Library
** String
** Object
- superclass of all other classes
- reference variable of type Object can refer to an object of any other class.
*** methods
|           |   |
|-----------+---|
| clone     |   |
| equals    |   |
| finalize  |   |
| getClass  |   |
| hashCode  |   |
| notify    |   |
| notifyAll |   |
| toString  |   |
| wait      |   |

*** Passed as Param
- Pass as reference, will change the object passsed as param outside of method.
* Scripting
- remove .java extension
- chmod +x
- add shebang w/ *--source N*
- java dependencies can be added w/ *-cp /path/to/xxx.jar*

#+begin_src java
#!/usr/bin/java --source 17

public class HelloScripting {
	public static void main(String[] args) {
		System.out.println("Hello " + args[0]);
	}
}

#+end_src
* Jobs
** oracle backend
BS or MS degree in Computer Science or related field
3+ years of professional experience in industry
Experienced and efficient programmer in Java
Demonstrable strong programming skills in core Java by writing performant and extensible code
Firm grasp of cloud software concepts
Good familiarity and understanding of software design patterns
Experience writing well-maintainable RESTful web services
Experience with REST APIs, JSON, Web Security, and micro-services architecture
Basic understanding of distributed systems
Eager to work on a highly scalable, performance optimized infrastructure which elastically handles customer needs
Ability to adapt to a fast-paced work environment and can quickly adjust to changing priorities
Detail oriented with focus on quality of the product, data, and code
Fluency in spoken/read/written English
** redhat senior java
Broad experience with technologies like Apache Kafka, Keycloak, API Management, Apache Camel and Fuse, Spring Boot, microservices, and serverless and functions
3+ years of experience working in a top-tier systems vendor, either in software engineering, consulting, sales engineering, or a solutions architect role
5+ years of experience with full life cycle application development, including proven architecture experience, e.g., agile methodology, continuous integration and continuous delivery (CI/CD), test-driven development (TDD), service-oriented architecture (SOA), message-oriented middleware (MOM), governance, high availability, scaling, distributed applications, clustering, etc.
3+ years of experience with cloud, e.g., Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure, and container technologies, mainly Docker and Kubernetes or Red Hat OpenShift Container Platform
Ability to develop excellent presentation skills; ability to present to small and large groups of mixed audiences like business, technical, management, and leadership
Excellent written and verbal communication skills in English
Willingness to travel up to 50% of the time, within the North America region, when needed for events and meetings
Project lead, architecture design, or sales engineering experience is a plus
Bachelor's or master's degree is a plus
** Kamila code
- lambda
- stream
- datetime
- git
- linux
- api rest
- http
- maven
- gradle
- spring: web boot data security
- test unit junit mockito piramede test
- swagger
- nuvem: aws
- mensageria
- scrum, agile
- microserviços
** Vincius Godoy
Com certeza, pode ficar no final da lista. Nesse meio tempo vale mais a pena estudar algumas tecnologias importantes como a Collections, o JPA e o SpringBoot. Além de aprofundar o uso de reflexão e anotations.
** meta
Quais serão as suas responsabilidades?


    Desenvolvimento de APIs para integração entre sistemas;
    Alteração em interfaces;
    Manutenção de sistemas legados;
    Suporte a equipe de QA para realização dos testes;

O que você precisa para participar desse processo seletivo?
    Experiência mínima de 3 anos em JAVA;
    Domínio na plataforma JEE – JPA, EJB, Servelets, JSP, JSF;
    Domínio em Spring Boot e Micro serviços;
    Domínio em GIT e SVN;
    Domínio em SQL, DDL e DML;
    Fortes conhecimentos em linguagem SQL;
    Fortes conhecimentos em Bancos de dados PostgreSQL ;
    Inglês técnico, nível intermediário;
* Projects idea
- TODO List. Implementa um Trello usando só Java.
- Sisteminha de caixa de restaurante. Pega o pedido, vai pra cozinha, faz balanço de estoque, etc...
- Sistema de agendamento de consulta. Pode evoluir para um sistema de gerenciamento de prontuário em que o médico usa pra fazer anamnese.
- Blog? Porque não?! Se é pra mostrar o conhecimento faz um MVC de um blog aí. Depois bota uma engine Markdown.
- Quer trabalhar com dados? Consume um dataset e faz mas estatísticas ou modelo ML. Usa o DL4J.
- a basic rest-api for a CRUD app, using JPA to write to a SQL database, like PostGres. That
