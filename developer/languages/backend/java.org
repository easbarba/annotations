#+TITLE: Java

* Summary
:PROPERTIES:
:TOC:      :include all
:END:
:CONTENTS:
- [[#summary][Summary]]
- [[#progress][Progress]]
  - [[#books][Books]]
  - [[#sloc][SLOC]]
- [[#base][Base]]
  - [[#types][Types]]
    - [[#integers][Integers]]
      - [[#byte][byte]]
      - [[#short][short]]
      - [[#int][int]]
      - [[#long][long]]
    - [[#floating][Floating]]
      - [[#float][float]]
      - [[#double][double]]
    - [[#strings][Strings]]
    - [[#characters][Characters]]
    - [[#boolean][Boolean]]
  - [[#variables][Variables]]
  - [[#objects][Objects]]
    - [[#passed-as-param][Passed as Param]]
  - [[#classes][Classes]]
    - [[#access-control][Access Control]]
      - [[#public][Public]]
      - [[#private][Private]]
      - [[#protected][Protected]]
    - [[#static][Static]]
    - [[#final][Final]]
    - [[#seal][Seal]]
    - [[#inheritance][inheritance]]
    - [[#super][super]]
    - [[#abstract-classes][Abstract Classes]]
- [[#library][Library]]
  - [[#string][String]]
  - [[#object][Object]]
    - [[#methods][methods]]
  - [[#interfaces][Interfaces]]
- [[#scripting][Scripting]]
:END:
* Progress
** Books
| name                    | chapter                   | @                         |
|-------------------------+---------------------------+---------------------------|
| Java Complete Reference | 9 Packages and Interfaces | Private Interface Methods |
| Effective Java 9        |                           |                           |

** SLOC
| Source Code | folder | file | @ |
|-------------+--------+------+---|
| jdk         |        |      |   |

* Base
** Types
*** Integers
- are signed, positive and negative values

**** byte
- smallest integer type
- –128 to 127

#+begin_src java
byte b, c;
#+end_src

**** short
- range from –32,768 to 32,767

#+begin_src java
short s;
short t;
#+end_src
**** int
- range from –2,147,483,648 to 2,147,483,647
- byte and short values in expressions are promoted to int when evaluated
#+begin_src java
int x = 0b1010; // integer binary
int y = 123_456_789;
int y = 123___456___789;
#+end_src
**** long
*** Floating
- real numbers
- IEEE–754
- defaults to double precision
- supports hexadecimal floating-point

#+begin_src java
0x12.2P2 // hexadecimal fp
double num = 9_423_497_862.0;
#+end_src

**** float
- 1.4e–045 to 3.4e+038
- single-precision
- takes half as much space as double precision
- imprecise when the values are either very large or very small

#+begin_src java
float hightemp, lowtemp;
#+end_src
**** double
- 4.9e–324 to 1.8e+308

#+begin_src java
// Compute the area of a circle.
class Area {
    public static void main(String[] args) {
        double pi, r, a;
        r = 10.8; // radius of circle
        pi = 3.1416; // pi, approximately
        a = pi * r * r; // compute area
        System.out.println("Area of circle is " + a);
    }
}
#+end_src
*** Strings
#+begin_src java
"Hello World"
"two\nlines"
" \"This is in quotes\""
#+end_src
*** Characters
- store characters
- range of 0 to 65,535
- able to manipulate with the integer operators

#+begin_src java
'\u0061' // ISO-Latin-1 'a'
'\ua432 ' // ꐲ - Japanese Katakana character.

// Demonstrate char data type.
class CharDemo {
    public static void main(String[] args) {
        char ch1, ch2;
        ch1 = 88; // code for X
        ch2 = 'Y';
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
    }
}
#+end_src

*** Boolean
- true
- false
- wont convert into any numerical representation

#+begin_src java
// Demonstrate boolean values.
class BoolTest {
    public static void main(String[] args) {
        boolean b;
        b = false;
        System.out.println("b is " + b);
        b = true;
        System.out.println("b is " + b);
        // a boolean value can control the if statement
        if(b) System.out.println("This is executed.");
        b = false;
        if(b) System.out.println("This is not executed.");
        // outcome of a relational operator is a boolean value
        System.out.println("10 > 9 is " + (10 > 9));

    }
}
#+end_src
** Variables
- an identifier, a type, and an optional initialize
- has a scope, which defines their visibility, and lifetime
- must be declared before being used

#+begin_src java
int a, b, c;
int d = 3, e, f = 5;
byte z = 22;
double pi = 3.14159;
char x = 'x';
#+end_src
** Objects
*** Passed as Param
- Pass as reference, will change the object passsed as param outside of method.
** Classes
*** Access Control
**** Public
- can be accessed by any other code
- default access
**** Private
- can only be accessed by other members of its class.
**** Protected
- applies only when inheritance is involved
*** Static
- can only directly call other static methods of their class
- can only directly access static variables of their class.
- cannot refer to this or super
- are, essentially, global variables
*** Final
- prevents its contents from being modified, making it, essentially, a constant.
- you must initialize a final field when it is declared.
- can give it a value when it is declared or assign it a value within a constructor


- prevents methods overriding
- sometimes provide a performance enhancement (inline calls)

#+begin_src java
class A {
	final void meth() {
		System.out.println("This is a final method.");
	}
}
class B extends A {
	void meth() { // ERROR! Can't override.
		System.out.println("Illegal!");
	}
}
#+end_src

- prevents inheritance

#+begin_src java
final class A {
	//...
}
// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
	//...
}
#+end_src
*** Seal
*** inheritance
- inherits all from super object
- single-inheritance
- private on superclass elements are not inherited by subclasses

#+begin_src java
class A {
	int i, j;
	void showij() {
		System.out.println("i and j: " + i + " " + j);
	}
}
// Create a subclass by extending class A.
class B extends A {
	int k;
	void showk() {
		System.out.println("k: " + k);
	}
	void sum() {
		System.out.println("i+j+k: " + (i+j+k));
	}
}

#+end_src
*** super
- must always be the first statement executed inside a subclass’ constructor.
*** Abstract Classes

* Library
** String
** Object
- superclass of all other classes
- reference variable of type Object can refer to an object of any other class.
*** methods
|           |   |
|-----------+---|
| clone     |   |
| equals    |   |
| finalize  |   |
| getClass  |   |
| hashCode  |   |
| notify    |   |
| notifyAll |   |
| toString  |   |
| wait      |   |
** Interfaces
- Prior to JDK 8, an interface could not define any implementation whatsoever.
- Beginning with JDK 8, it is possible to add a default implementation to an interface method.
- JDK 8 also added static interface methods
- W/ JDK 9 can include private methods

#+begin_src java
interface Callback {
    void callback(int param);
}
#+end_src

- implicitly final and static
- methods and variables are implicitly public.
- interface's method must be public

#+begin_src java
class Client implements Callback { // interface's method must be public
// Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }
}
#+end_src

#+begin_src java
class Client implements Callback {
    // Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }

    void nonIfaceMeth() {
        System.out.println("Classes that implement interfaces " + "may also define other members, too.");
    }
}
#+end_src

Interface as variable reference
- An interface reference variable has knowledge only of the methods declared by its interface declaration.

#+begin_src java
class TestIface {
    public static void main(String[] args) {
        Callback c = new Client();
        c.callback(42);
    }
}
#+end_src

Partial Implementations
- not fully implement the methods required by that interface, then that class must be declared as abstract.
- Any class that inherits Incomplete must implement callback( ) or be declared abstract itself.

#+begin_src java
abstract class Incomplete implements Callback {
    int a, b;

    void show() {
        System.out.println(a + " " + b);
    }
    // ...
}
#+end_src

Nested Interfaces

- can be declared as public, private, or protected.

#+begin_src java
class A {
    // this is a nested interface
    public interface NestedIF {
        boolean isNotNegative(int x);
    }
}

// B implements the nested interface.
class B implements A.NestedIF {
    public boolean isNotNegative(int x) {
        return x < 0 ? false : true;
    }
}

class NestedIFDemo {
    public static void main(String[] args) {
        // use a nested interface reference
        A.NestedIF nif = new B();
        if (nif.isNotNegative(10))
            System.out.println("10 is not negative");
        if (nif.isNotNegative(-12))
            System.out.println("this won't be displayed");
    }
}
#+end_src

Extends

- must provide implementations for all methods required by the interface inheritance chain

#+begin_src java
// One interface can extend another.
interface A {
    void meth1();

    void meth2();
}

// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A {
    void meth3();
}

// This class must implement all of A and B
class MyClass implements B {
    public void meth1() {
        System.out.println("Implement meth1().");
    }

    public void meth2() {
        System.out.println("Implement meth2().");
    }

    public void meth3() {
        System.out.println("Implement meth3().");
    }
}

class IFExtend {
    public static void main(String[] args) {
        MyClass ob = new MyClass();
        ob.meth1();
        ob.meth2();
        ob.meth3();
    }
}
#+end_src

Default method

- provide a body, rather than being abstract.
- supplies an implementation that will be used if no other implementation is explicitly provided
- JDK 8


#+begin_src java
interface IntStack {
    void push(int item); // store an item
    int pop(); // retrieve an item
    // Because clear( ) has a default, it need not be
    // implemented by a preexisting class that uses IntStack.
    default void clear() {
        System.out.println("clear() not implemented.");
    }
}
#+end_src

- explicitly refer to a default implementation in an inherited interface by using super.

#+begin_src
Alpha.super.reset();
#+end_src

*Interface static Methods*

#+begin_src java
public interface MyIF {
    // This is a "normal" interface method declaration.
    // It does NOT define a default implementation.
    int getNumber();

    // This is a default method. Notice that it provides
    // a default implementation.
    default String getString() {
        return "Default String";
    }

    // This is a static interface method.
    static int getDefaultNumber() {
        return 0;
    }
}

// ...
int defNum = MyIF.getDefaultNumber();
#+end_src

*Private Interface Methods*

- can be called only by a default method or another private method defined by the same interface.
* Scripting
- remove .java extension
- chmod +x
- add shebang w/ *--source N*
- java dependencies can be added w/ *-cp /path/to/xxx.jar*

#+begin_src java
#!/usr/bin/java --source 17

public class HelloScripting {
	public static void main(String[] args) {
		System.out.println("Hello " + args[0]);
	}
}

#+end_src
