#+TITLE: Java

* Progress
** Books
| name                     | chapter                                                 | @            |
|--------------------------+---------------------------------------------------------+--------------|
| Java Complete Reference  | 12 Enumerations, Autoboxing, and Annotations            | Enumerations |
| Junit                    | 1                                                       |              |
| Coding Interview in Java | 3 Common Non-Technical Questions and How To Answer Them |              |
| Effective Java 9         |                                                         |              |

** SLOC
| Source Code | folder                               | file           | @ |
|-------------+--------------------------------------+----------------+---|
| openjdk     | src/java.base/share/classes/java/io  | Bits.java      |   |
| common-cli  | src/main/java/org/apache/commons/cli | GnuParser.java |   |

* Base
** Types
*** Integers
- are signed, positive and negative values

**** byte
- smallest integer type
- –128 to 127

#+begin_src java
byte b, c;
#+end_src

**** short
- range from –32,768 to 32,767

#+begin_src java
short s;
short t;
#+end_src
**** int
- range from –2,147,483,648 to 2,147,483,647
- byte and short values in expressions are promoted to int when evaluated
#+begin_src java
int x = 0b1010; // integer binary
int y = 123_456_789;
int y = 123___456___789;
#+end_src
**** long
*** Floating
- real numbers
- IEEE–754
- defaults to double precision
- supports hexadecimal floating-point

#+begin_src java
0x12.2P2 // hexadecimal fp
double num = 9_423_497_862.0;
#+end_src

**** float
- 1.4e–045 to 3.4e+038
- single-precision
- takes half as much space as double precision
- imprecise when the values are either very large or very small

#+begin_src java
float hightemp, lowtemp;
#+end_src
**** double
- 4.9e–324 to 1.8e+308

#+begin_src java
// Compute the area of a circle.
class Area {
    public static void main(String[] args) {
        double pi, r, a;
        r = 10.8; // radius of circle
        pi = 3.1416; // pi, approximately
        a = pi * r * r; // compute area
        System.out.println("Area of circle is " + a);
    }
}
#+end_src
*** Strings
#+begin_src java
"Hello World"
"two\nlines"
" \"This is in quotes\""
#+end_src
*** Characters
- store characters
- range of 0 to 65,535
- able to manipulate with the integer operators

#+begin_src java
'\u0061' // ISO-Latin-1 'a'
'\ua432 ' // ꐲ - Japanese Katakana character.

// Demonstrate char data type.
class CharDemo {
    public static void main(String[] args) {
        char ch1, ch2;
        ch1 = 88; // code for X
        ch2 = 'Y';
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
    }
}
#+end_src

*** Boolean
- true
- false
- wont convert into any numerical representation

#+begin_src java
// Demonstrate boolean values.
class BoolTest {
    public static void main(String[] args) {
        boolean b;
        b = false;
        System.out.println("b is " + b);
        b = true;
        System.out.println("b is " + b);
        // a boolean value can control the if statement
        if(b) System.out.println("This is executed.");
        b = false;
        if(b) System.out.println("This is not executed.");
        // outcome of a relational operator is a boolean value
        System.out.println("10 > 9 is " + (10 > 9));

    }
}
#+end_src
** Collection Types
*** Arrays
*asList*
*fill*
*copyOf*
*compare*
*sort*
** Packages
#+begin_src java
package org.foo.bar
#+end_src

*importing*
- optional, as oposing fully qualified name usage.

- fully qualified
#+begin_src java
class MyDate extends java.util.Date {
...
}
#+end_src

#+begin_src java
import java.util.Date;
import java.io.*;

class MyDate extends Date {
}
#+end_src

** Classes
*** Member Acess
** Modifiers
*** final
#+begin_src sh
final int
#+end_src
On methods prevent it to be overriden
#+begin_src sh
final void meth() {
System.out.println("This is a final method.");
}
#+end_src

** Variables
- an identifier, a type, and an optional initialize
- has a scope, which defines their visibility, and lifetime
- must be declared before being used

#+begin_src java
int a, b, c;
int d = 3, e, f = 5;
byte z = 22;
double pi = 3.14159;
char x = 'x';
#+end_src
** Classes
*** Access Control
**** Public
- can be accessed by any other code
- default access
**** Private
- can only be accessed by other members of its class.
**** Protected
- applies only when inheritance is involved
*** Static
- can only directly call other static methods of their class
- can only directly access static variables of their class.
- cannot refer to this or super
- are, essentially, global variables
*** Final
- prevents its contents from being modified, making it, essentially, a constant.
- you must initialize a final field when it is declared.
- can give it a value when it is declared or assign it a value within a constructor


- prevents methods overriding
- sometimes provide a performance enhancement (inline calls)

#+begin_src java
class A {
	final void meth() {
		System.out.println("This is a final method.");
	}
}
class B extends A {
	void meth() { // ERROR! Can't override.
		System.out.println("Illegal!");
	}
}
#+end_src

- prevents inheritance

#+begin_src java
final class A {
	//...
}
// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
	//...
}
#+end_src
*** Seal
*** Inheritance
- inherits all from super object
- single-inheritance
- private on superclass elements are not inherited by subclasses

#+begin_src java
class A {
	int i, j;
	void showij() {
		System.out.println("i and j: " + i + " " + j);
	}
}
// Create a subclass by extending class A.
class B extends A {
	int k;
	void showk() {
		System.out.println("k: " + k);
	}
	void sum() {
		System.out.println("i+j+k: " + (i+j+k));
	}
}
#+end_src
*** super
- must always be the first statement executed inside a subclass’ constructor.
*** Abstract Classes
#+begin_src java
// A Simple demonstration of abstract.
abstract class A {
  abstract void callme();
  // concrete methods are still allowed in abstract classes
  void callmetoo() { System.out.println("This is a concrete method."); }
}
class B extends A {
  void callme() { System.out.println("B's implementation of callme."); }
}
class AbstractDemo {
  public static void main(String[] args) {
    B b = new B();
    b.callme();
    b.callmetoo();
  }
}
#+end_src
*** useful methods to implement
#+begin_src java
equals()
hashCode()
toString()
#+end_src
** Interfaces
- Cannot mantain state
- JDK 7: an interface could not define any implementation whatsoever.
- JDK 8:  adds a default implementation to an interface method.
- JDK 8: adds static interface methods
- JDK 9: includes private methods

#+begin_src java
interface Callback {
    void callback(int param);
}
#+end_src

- implicitly final and static
- methods and variables are implicitly public.
- interface's method must be public

#+begin_src java
class Client implements Callback { // interface's method must be public
// Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }
}
#+end_src

#+begin_src java
class Client implements Callback {
    // Implement Callback's interface
    public void callback(int p) {
        System.out.println("callback called with " + p);
    }

    void nonIfaceMeth() {
        System.out.println("Classes that implement interfaces " + "may also define other members, too.");
    }
}
#+end_src

Interface as variable reference
- An interface reference variable has knowledge only of the methods declared by its interface declaration.

#+begin_src java
class TestIface {
    public static void main(String[] args) {
        Callback c = new Client();
        c.callback(42);
    }
}
#+end_src

Partial Implementations
- not fully implement the methods required by that interface, then that class must be declared as abstract.
- Any class that inherits Incomplete must implement callback( ) or be declared abstract itself.

#+begin_src java
abstract class Incomplete implements Callback {
    int a, b;

    void show() {
        System.out.println(a + " " + b);
    }
    // ...
}
#+end_src

Nested Interfaces

- member interfaces
- can be declared as public, private, or protected.
- differs from a top-level interface, which must either be declared as public or use the default access level


#+begin_src java
class A {
    // this is a nested interface
    public interface NestedIF {
        boolean isNotNegative(int x);
    }
}

// B implements the nested interface.
class B implements A.NestedIF {
    public boolean isNotNegative(int x) {
        return x < 0 ? false : true;
    }
}

class NestedIFDemo {
    public static void main(String[] args) {
        // use a nested interface reference
        A.NestedIF nif = new B();
        if (nif.isNotNegative(10))
            System.out.println("10 is not negative");
        if (nif.isNotNegative(-12))
            System.out.println("this won't be displayed");
    }
}
#+end_src

Extending interfaces

- must provide implementations for all methods required by the interface inheritance chain

#+begin_src java
// One interface can extend another.
interface A {
    void meth1();
    void meth2();
}

// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A {
    void meth3();
}

// This class must implement all of A and B
class MyClass implements B {
    public void meth1() {
        System.out.println("Implement meth1().");
    }

    public void meth2() {
        System.out.println("Implement meth2().");
    }

    public void meth3() {
        System.out.println("Implement meth3().");
    }
}

class IFExtend {
    public static void main(String[] args) {
        MyClass ob = new MyClass();
        ob.meth1();
        ob.meth2();
        ob.meth3();
    }
}
#+end_src

Default method

- extension method
- provide a body, rather than being abstract.
- supplies an implementation that will be used if no other implementation is explicitly provided
- JDK 8

#+begin_src java
interface IntStack {
    void push(int item); // store an item
    int pop(); // retrieve an item
    // Because clear( ) has a default, it need not be
    // implemented by a preexisting class that uses IntStack.
    default void clear() {
        System.out.println("clear() not implemented.");
    }
}
#+end_src

- refers to a default implementation in an inherited interface by using super.

#+begin_src
Alpha.super.reset();
#+end_src

*Interface static Methods*

- no implementation of the interface is necessary, and no instance of the interface is required, in order to call a static method.

#+begin_src java
public interface MyIF {
    // This is a "normal" interface method declaration.
    // It does NOT define a default implementation.
    int getNumber();

    // This is a default method. Notice that it provides
    // a default implementation.
    default String getString() {
        return "Default String";
    }

    // This is a static interface method.
    static int getDefaultNumber() {
        return 0;
    }
}

// ...
int defNum = MyIF.getDefaultNumber();
#+end_src

*Private Interface Methods*

- only called by a default method or another private method defined by the same interface.
- cannot be used by code outside the interface in which it is defined, including subinterfaces
- used as a shared common piece of code

#+begin_src java
// Another version of IntStack that has a private interface
// method that is used by two default methods.
interface IntStack {
    void push(int item); // store an item

    int pop();
    // retrieve an item

    // A default method that returns an array that contains
    // the top n elements on the stack.
    default int[] popNElements(int n) {
        // Return the requested elements.
        return getElements(n);
    }

    // A default method that returns an array that contains
    // the next n elements on the stack after skipping elements.
    default int[] skipAndPopNElements(int skip, int n) {
        // Skip the specified number of elements.
        getElements(skip);
        // Return the requested elements.
        return getElements(n);
    }

    // A private method that returns an array containing
    // the top n elements on the stack
    private int[] getElements(int n) {
        int[] elements = new int[n];
        for (int i = 0; i < n; i++)
            elements[i] = pop();
        return elements;
    }
}
#+end_src
** Exception Handling
- can be generated by the Java run-time system
- can be manually generated by your code
- all exception types are subclasses of the built-in class Throwable

#+begin_src java
try {
// block of code to monitor for errors
}
catch (ExceptionType1 exOb) {
// exception handler for ExceptionType1
}
catch (ExceptionType2 exOb) {
// exception handler for ExceptionType2
}
// ...
finally {
// block of code to be executed after try block ends
}
#+end_src
*** Keywords
*try/catch*
- allows you to fix the error
- prevents the program from automatically terminating
- well-constructed catch clauses should be to resolve the exceptional condition and then continue on as if the error had never happened.
#+begin_src java
class Exc2 {
  public static void main(String[] args) {
    int d, a;
    try { // monitor a block of code.
      d = 0;
      a = 42 / d;
      System.out.println("This will not be printed.");
    } catch (ArithmeticException e) { // catch divide-by-zero error
      System.out.println("Division by zero.");
    }
    Chapter 10 Exception Handling 231 System.out.println(
        "After catch statement.");
  }
}
#+end_src

*throw*

*throws*

*finally*

*Exception class*
- for exceptional conditions that user programs should catch.
- for class that you will subclass to create your own custom exception types.

*Error class*
- indicates errors having to do with the run-time environment
- exceptions that are not expected to be caught under normal circumstances by your program.
*** Types
** Enumerations
- specifies the only values that a data type can legally have.
- can have constructors, methods, and instance variables.
- can have constructors, add instance variables and methods, and even implement interfaces
- inherits from java.lang.Enum
#+begin_src java
enum Apple {
    Jonathan, GoldenDel, RedDel, Winesap, Cortland
}
class EnumDemo {
  public static void main(String[] args) {
    Apple ap;
    ap = Apple.RedDel;
    // Output an enum value.
    System.out.println("Value of ap: " + ap);
    System.out.println();
    ap = Apple.GoldenDel;
    // Compare two enum values.
    if (ap == Apple.GoldenDel)
      System.out.println("ap contains GoldenDel.\n");
    // Use an enum to control a switch statement.
    switch (ap) {
    case Jonathan:
      System.out.println("Jonathan is red.");
      break;
    case GoldenDel:
      System.out.println("Golden Delicious is yellow.");
      break;
    case RedDel:
      System.out.println("Red Delicious is red.");
      break;
    case Winesap:
      System.out.println("Winesap is red.");
      break;
    case Cortland:
      System.out.println("Cortland is red.");
      break;
    }
  }
}
#+end_src

*values*
Returns an array that contains a list of the enumeration constants

#+begin_src java
public static enum-type [ ] values( )
#+end_src

*valueOf*

Returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
public static enum-type valueOf(String str )
#+end_src

returns the enumeration constant whose value corresponds to the string
passed in str.

#+begin_src java
enum Apple { Jonathan, GoldenDel, RedDel, Winesap, Cortland }
class EnumDemo2 {
  public static void main(String[] args) {
    Apple ap;
    System.out.println("Here are all Apple constants:");
    // use values()
    Apple[] allapples = Apple.values();
    for (Apple a : allapples)
      System.out.println(a);
    System.out.println();
    // use valueOf()
    ap = Apple.valueOf("Winesap");
    System.out.println("ap contains " + ap);
  }
}
#+end_src


*constructor*

#+begin_src java
// Use an enum constructor, instance variable, and method.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel(12),
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  int getPrice() { return price; }
}

class EnumDemo3 {
  public static void main(String[] args) {
    Apple ap;
    // Display price of Winesap.
    System.out.println("Winesap costs " + Apple.Winesap.getPrice() +
                       " cents.\n");
    // Display all apples and prices.
    System.out.println("All apple prices:");
    for (Apple a : Apple.values())
      System.out.println(a + " costs " + a.getPrice() + " cents.");
  }
}
#+end_src

- multiple constructors

#+begin_src java
// Use an enum constructor.
enum Apple {
  Jonathan(10),
  GoldenDel(9),
  RedDel,
  Winesap(15),
  Cortland(8);
  private int price; // price of each apple
  // Constructor
  Apple(int p) { price = p; }
  // Overloaded constructor
  Apple() { price = -1; }
  int getPrice() { return price; }
}
#+end_src
** Annotations
*** meta annotations
** Generics
- parameterized types

#+begin_src java
class Gen<T> {
  T ob;

  Gen(T o) {
    ob = o;
  }

  T getOb() {
    return ob;
  }

  void showType() {
    System.out.println("Type of T is " + ob.getClass().getName());
  }
}

Gen<Integer> iOb;
// Create a Gen<Integer> object and assign its
// reference to iOb. Notice the use of autoboxing
// to encapsulate the value 88 within an Integer object.
iOb = new Gen<Integer>(88);
#+end_src
** Streams
** Collections
* Standard Library
** java.lang

* Commands
** java
launch a Java application

*-jar*

#+begin_src java
java -jar target/taco-cloud-0.0.1-SNAPSHOT.jar
#+end_src

*-cp*

#+begin_src shell
java -cp target/zae-1.0-SNAPSHOT.jar org.easbarba.zae.App
#+end_src

*-m or --module module[/mainclass]*

*--list-modules*
** jlink
#+begin_src sh
jlink --add-modules java.base --output javao
#+end_src

** javac
read Java declarations and compile them into class files
** javadoc
** javap
** jshell

* Utilities
- jlink
- jpackage
  -
* Environment Variables
*JAVA_HOME*
*JDK_JAVA_OPTIONS*

* Library
** String
** Object
- superclass of all other classes
- reference variable of type Object can refer to an object of any other class.
*** methods
|           |   |
|-----------+---|
| clone     |   |
| equals    |   |
| finalize  |   |
| getClass  |   |
| hashCode  |   |
| notify    |   |
| notifyAll |   |
| toString  |   |
| wait      |   |

*** Passed as Param
- Pass as reference, will change the object passsed as param outside of method.
* Scripting
- remove .java extension
- chmod +x
- add shebang w/ *--source N*
- java dependencies can be added w/ *-cp /path/to/xxx.jar*

#+begin_src java
#!/usr/bin/java --source 17

public class HelloScripting {
	public static void main(String[] args) {
		System.out.println("Hello " + args[0]);
	}
}

#+end_src
* Projects idea
xcdesz4 points7 hours ago
The Baeldung spring-boot tutorials are excellent and pretty beginner friendly. I use them even after doing this stuff for years.

If you are going into java, Spring-Boot is probably something you must learn. For starters, make a basic rest-api for a CRUD app, using JPA to write to a SQL database, like PostGres. That is the standard baseline for most java projects that you will encounter in the wild.

Also learn how to write unit tests for the backend endpoints. Learn Git as well, and you will fit right in to most java teams.

A simple spring boot project with static apis would be great, make sure you are familiar with maven or gradle. Get use to postman and calling them locally. Then add a database like postgres and interface it with spring data. After that's working with simple CRUD apis then you can start looking at something like docker or testing or w.e youre interested in. The key is just start small and keep adding onto it. I did something like this awhile ago.
* Jobs
** oracle backend
BS or MS degree in Computer Science or related field
3+ years of professional experience in industry
Experienced and efficient programmer in Java
Demonstrable strong programming skills in core Java by writing performant and extensible code
Firm grasp of cloud software concepts
Good familiarity and understanding of software design patterns
Experience writing well-maintainable RESTful web services
Experience with REST APIs, JSON, Web Security, and micro-services architecture
Basic understanding of distributed systems
Eager to work on a highly scalable, performance optimized infrastructure which elastically handles customer needs
Ability to adapt to a fast-paced work environment and can quickly adjust to changing priorities
Detail oriented with focus on quality of the product, data, and code
Fluency in spoken/read/written English
** redhat senior java
Broad experience with technologies like Apache Kafka, Keycloak, API Management, Apache Camel and Fuse, Spring Boot, microservices, and serverless and functions
3+ years of experience working in a top-tier systems vendor, either in software engineering, consulting, sales engineering, or a solutions architect role
5+ years of experience with full life cycle application development, including proven architecture experience, e.g., agile methodology, continuous integration and continuous delivery (CI/CD), test-driven development (TDD), service-oriented architecture (SOA), message-oriented middleware (MOM), governance, high availability, scaling, distributed applications, clustering, etc.
3+ years of experience with cloud, e.g., Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure, and container technologies, mainly Docker and Kubernetes or Red Hat OpenShift Container Platform
Ability to develop excellent presentation skills; ability to present to small and large groups of mixed audiences like business, technical, management, and leadership
Excellent written and verbal communication skills in English
Willingness to travel up to 50% of the time, within the North America region, when needed for events and meetings
Project lead, architecture design, or sales engineering experience is a plus
Bachelor's or master's degree is a plus
