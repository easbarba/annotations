#+TILE: PostgreSQL

* Progress
| book                   | chapter                                 | @                   |
|------------------------+-----------------------------------------+---------------------|
| Learn PostgreSQL 12/13 | Advanced Statements                     | Aggregate functions |
| Essential Postgres     | SELECTING DATA FROM A POSTGRES DATABASE |                     |
| Boson Treinamentos YT  | Views                                   |                     |

* Base
** Tables
| Types            |                                                                   |
|------------------+-------------------------------------------------------------------|
| Temporary tables | Very fast tables, visible only to the user who created them       |
| Unlogged tables  | Very fast tables to be used as support tables common to all users |
| Logged tables    | Regular tables                                                                  |

*** create
#+begin_src sql
CREATE TABLE dummytable (dummyfield integer not null primary key);

CREATE TABLE users (
, username text NOT NULL
, gecos text
, email text NOT NULL
, PRIMARY KEY(pk)
, UNIQUE(username)
);

INSERT INTO categories (title,description) values
('apple', 'fruits'), ('orange','fruits'),('lettuce','vegetable'), ('pataya', NULL);

 with owner ... Encoding ... LC_* ... Tablespace ... Connection limite -1;
#+end_src

#+begin_src sql
create table posts (pk int generated always as identity,
title text not null,
content text,
author integer not NULL,
category integer,
primary key(pk),
unique(author));

#+end_src

#+begin_src sql
create table new_categories as select * from categories limit 0;
#+end_src

*** drop
Deletes the table structure from the database, along with any data stored in the table.

#+begin_src sql
DROP TABLE tablename;
#+end_src

#+begin_src sql
DROP TABLE IF EXISTS users;
#+end_src

*** alter
#+begin_src sql
alter table j_posts_tags add constraint j_posts_tags_pkey primary key (tag_pk,post_pk);
ALTER TABLE customers ADD COLUMN phone VARCHAR;
ALTER TABLE customers ADD COLUMN contact_name VARCHAR NOT NULL;
#+end_src
*** update

#+begin_src sql
update temp_categories set title='peach' where pk = 14;

UPDATE customers
SET contact_name = 'John Doe'
WHERE id = 1;

UPDATE customers
SET contact_name = 'Mary Doe'
WHERE id = 2;

UPDATE customers
SET contact_name = 'Lily Bush'
WHERE id = 3;

UPDATE t_posts p SET title=p.title||' last updated'||current_date::text
WHERE EXISTS (SELECT 1 FROM categories c WHERE c.pk=p.category AND c.title='apple' limit 1);

UPDATE t_posts p
SET title=p.title||' last updated '||current_date::text
FROM categories c
WHERE c.pk=p.category AND c.title='apple';

UPDATE t_posts p SET title=p.title||' last updated'||current_date::text
WHERE EXISTS (SELECT 1 FROM categories c WHERE c.pk=p.category AND c.title='apple' LIMIT 1) returning pk,title,category;
#+end_src

*** truncate
Deletes records from a table without removing table structure

- ddl

#+begin_src sql
TRUNCATE TABLE categories;
#+end_src
*** delete
- ml

delete all records

#+begin_src sql
DELETE FROM name_table;
#+end_src


delete a group of records

#+begin_src sql
DELETE FROM name_table WHERE col=value;
DELETE FROM product WHERE price<2.90;

DELETE FROM t_posts p WHERE EXISTS (SELECT 1 FROM categories c
WHERE c.pk=p.category AND c.title='apple') RETURNING pk,title,category;
#+end_src

*** insert
#+begin_src sql
INSERT INTO users (username,gecos,email) values
('myusername','mygecos','myemail');

INSERT INTO categories (title,description) values
('apple', 'fruits'), ('orange','fruits'),('lettuce','vegetable')
('xapple', 'fruits'), ('xorange','fruits'),('xlettuce','vegetable');
#+end_src
*** upsert
Insert a new record on top of the existing record or update an existing record.

- Does not exist in postgres
- use ON CONFLICT
*** returning
#+begin_src sql
INSERT INTO j_posts_tags VALUES(1,2) RETURNING *;
#+end_src

*** temporary
table visible only in the session where it was created

#+begin_src sql

forumdb=# create temp table if not exists temp_users
pk int GENERATED ALWAYS AS IDENTITY
,username text NOT NULL
,gecos text
,email text NOT NULL
,PRIMARY KEY( pk )
,UNIQUE ( username )
);

#+end_src

table visible only within our transaction

#+begin_src sql
forumdb=# begin work;
BEGIN

forumdb# create temp table if not exists temp_users (
pk int GENERATED ALWAYS AS IDENTITY
,username text NOT NULL
,gecos text
,email text NOT NULL
,PRIMARY KEY( pk )
,UNIQUE ( username )
) on commit drop;

forumdb=# commit work;
COMMIT

in this way :
forumdb=# \d temp_users;
Did not find any relation named "temp_users".

#+end_src


Creating a table starting from another table

#+begin_src sql
create temp table temp_categories as select * from categories;
#+end_src
*** unlogged
- not crash-safe
- much faster than logged tables
*** where
#+begin_src sql
SELECT * FROM categories WHERE description ='vegetable';

SELECT * FROM categories WHERE description ='fruits' AND title='orange';

SELECT * FROM categories WHERE description ='fruits' ORDER by 2 desc;
#+end_src
*** like
- case-sensitive

#+begin_src sql
select * from categories where title like 'a%';
select * from categories where title like '%e';
select * from categories where title like '%ap%';
select * from categories where title like 'A%';
select * from categories where upper(title) like 'A%';  -- like case-insensitive search
#+end_src
*** ilike
Performs case-insensitive search

#+begin_src sql
select * from categories where title ilike 'A%';
#+end_src
*** distinct

** Databases
*** create
#+begin_src sql
CREATE DATABASE dummydb;
#+end_src
*** drop
#+begin_src sqld
DROP DATABASE tablename;
#+end_src
*** copy
#+begin_src sql
CREATE DATABASE forumdb2 TEMPLATE forumdb;
#+end_src
*** size
**** via psql
#+begin_src conf
\x
\l+ databasename
#+end_src
**** via sql
#+begin_src sql
SELECT pg_database_size('forumdb');
SELECT pg_size_pretty(pg_database_size('forumdb'));
#+end_src
*** query
#+begin_src sql
select * from pg_database where datname='forumdb';
#+end_src
** SubQueries
#+begin_src sql
select * from categories where pk in (10,11);
select * from categories where not (pk=10 or pk=11);
select * from categories where pk not in (10,11);
select pk,title,content,author,category from posts where category in (select pk from categories where title ='orange');
select pk,title,content,author,category from posts where category not in (select pk from categories where title ='orange');
#+end_src
** CTEs
Common table expression

** join
*join*

#+begin_src sql
select c.pk,c.title,p.pk,p.category,p.title from categories c CROSS JOIN posts p;
select c.pk,c.title,p.pk,p.category,p.title from categories c inner join posts p on c.pk=p.category;
JOIN condition, we would have to rewrite the query in this way:
select distinct p.pk,p.title,p.content,p.author,p.category from categories c inner join posts p on c.pk=p.category where c.title='orange';
#+end_src

*left join*

#+begin_src sql
select c.*,p.category,p.title from categories c left join posts p on c.pk=p.category;
select c.* from categories c left join posts p on p.category=c.pk where p.category is null;
select c.*,p.category from categories c left join posts p on p.category=c.pk;
#+end_src

*right join*

#+begin_src sql
select c.*,p.category,p.title from posts p right join categories c on c.pk=p.category;
#+end_src

*inner join*

#+begin_src sql
select jpt.*,t.*,p.title from j_posts_tags jpt inner join tags t on jpt.tag_pk=t.pk inner join posts p on jpt.post_pk = p.pk;
#+end_src

*full outer join*

#+begin_src sql
select jpt.*,t.*,p.title from j_posts_tags jpt full outer join tags t on jpt.tag_pk=t.pk full outer join posts p on jpt.post_pk = p.pk;
#+end_src

*self join*

#+begin_src sql
select distinct p2.title,p2.author,p2.category from posts p1 inner join posts p2 on ( p1.category=p2.category and p1.author<>p2.author)
       where p1.author=1 and p2.author=2;
#+end_src
** conditions
*having*

#+begin_src sql
select category,count(*) from posts group by 1 having count(*) > 2;
select category,count(*) as category_count from posts group by category having count(*) > 2;
#+end_src

** null
Query null values

#+begin_src sql
SELECT title,description FROM categories WHERE description IS NULL;
select * from categories order by description NULLS first;
select * from categories order by description NULLS first;
#+end_src
** Operators
*or*

*in*

#+begin_src sql
select * from categories where pk in (10,11);
#+end_src

*not*

#+begin_src sql
select * from categories where not (pk=10 or pk=11);
select * from categories where pk not in (10,11);
select pk,title,content,author,category from posts where category
       not in (select pk from categories where title ='orange');
#+end_src

*exist*

#+begin_src sql
select pk,title,content,author,category from posts where exists
       (select 1 from categories where title ='orange' and posts.category=pk);


select pk,title,content,author,category from posts where not
       exists (select 1 from categories where title ='orange' and
       posts.category=pk);

select pk,title,content,author,category from posts where exists (select 1 from categories where title ='orange' and posts.category=pk);
select pk,title,content,author,category from posts where not exists (select 1 from categories where title ='orange' and posts.category=pk);
select * from categories c where not exists (select 1 from posts where category=c.pk);
#+end_src

*union*
- remove duplicates
- implies DISTINCT

#+begin_src sql
select title from categories union select tag from tags order by title;
#+end_src

*union all*
- wont remove duplicates
- faster

#+begin_src sql
select title from categories union all select tag from tags order by title;
#+end_src

*intersect*

#+begin_src sql
elect title from categories intersect select tag from tags order by 1;
#+end_src

*except*

#+begin_src sql
select title from categories except select tag from tags order by 1;
#+end_src

** Functions
*** custom functions
#+begin_src sql
CREATE FUNCTION Raptor_lastSurveyDate1(p_some_value bigint)
  RETURNS date
As $$
  SELECT max(date)
  FROM raptor_surveys
  WHERE nest = p_some_value;
$$ LANGUAGE SQL
#+end_src
*** misc
*coalesce*

given two or more parameters, returns the first value that is not NULL.

#+begin_src sql
select coalesce(NULL,'test'); -- test
select coalesce('orange','test'); -- orange
select coalesce(description,'No description') as description from categories order by 1;
#+end_src

*upper*
#+begin_src sql
select upper('orange');
select * from categories where upper(title) like 'A%';  -- like case-insensitive search
#+end_src*** aggregate functions

*** aggregate functions

*count*

#+begin_src sql
SELECT COUNT(*) FROM USERS;
select category,count(*) from posts group by category;  -- same as: select category,count(*) from posts group by 1;
select category,count(*) from posts group by category having count(*) > 2;
select category,count(*) as category_count from posts group by category;
#+end_src

*avg*

*max*

*min*

*sum*

** Clause
*limit*

limit the number of rows returned by a query

#+begin_src sql
select * from categories order by pk limit 1;
select * from categories order by pk limit 2;
SELECT title FROM "posts" ORDER BY "posts"."id" ASC LIMIT 4;
#+end_src

*offset*
skip a specific number of rows returned by the query

#+begin_src sql
select * from categories order by pk offset 1 limit 1;
SELECT title FROM "posts" ORDER BY "posts"."id" ASC LIMIT 4 OFFSET 4;
#+end_src

** Types
*** integer
** Tablespace
pg_tblspc
pg_default
pg_global
** Roles
- A role can be a single account, a group of accounts, or even both depending on how you configure it
- it should be either a single user or a single group, but not both.
- have a unique name or identifier, usually called the username.
- represents a collection of database permissions and connection properties.

*drop role*

#+begin_src sql
DROP ROLE [ IF EXISTS ] name [, ...]
#+end_src

#+begin_src sql

DROP ROLE IF EXISTS saitama;
#+end_src

*create role*

*grant*

*inspect*

**** Statements
|             |                             |
|-------------+-----------------------------|
| CREATE ROLE | create a role from scratch  |
| ALTER ROLE  | change some role properties |
| DROP ROLE   | remove an existing role     |
** Groups
** explain analyze
,,
#+begin_src sql
shine_development> EXPLAIN ANALYZE
SELECT *
FROM customers
WHERE
  lower(first_name) like 'pat%' OR
  lower(last_name) like 'pat%' OR
  lower(email) = 'pat@example.com'
ORDER BY
  email = 'pat@example.com' DESC,
  last_name ASC ;
QUERY PLAN
#+end_src

* DML - Data Manipulation Language
used to insert, delete, update, and select data inside databases

* DDL - Data Definition Language
commands are used to manage databases and tables

Alter table person add constraint unique_email unique(email)
Alter table person add  unique(email)
Update person set f = ket where id = 5
On conflict (id) do nothing;
On conflict (id) do update set email = excluded.email;
\dt

Name Varchar(6) not null,
Id integer not bull primary key
Car bigint references car (id)


Update person set car_I'd = 2 where id = 1
Left join car on ....
Where car.* is null;

\copy ( select * from person left join car on car_id = person.car_id to 'home/.../p.csv'  delimiter ',' csv header;
Alter sequence Orego person restart with 10;
Create extension if not exists 'uuid-assp'
\df

Comparison

Fetch
Row only
Between
Like '___@%'
Group by
Having
Count(*)
Sum
Min
Max
Avg
Interval
Extract

* Commands
** psql
a command-line client that allows you to interact with, connect, and administer
databases and the cluster itself.

|    |                                                         |
|----+---------------------------------------------------------|
| -l |                                                         |
| -d | The database name                                       |
| -U | The username                                            |
| -h | The host (either an IPv4 or IPv6 address or a hostname) |
|    |                                                         |

*** options
|                   |                                          |
|-------------------+------------------------------------------|
| \! COMMAND        | system commands                          |
| \dS               |                                          |
| \d                |                                          |
| \q                |                                          |
| \du               |                                          |
| \password         |                                          |
| \conninfo         |                                          |
| \pset null        |                                          |
| \pset null (NULL) | change how NULL is represented to (NULL) |
| \pset null NULL   |                                          |
| show hba_file     | show hba_file information                |
**** commands (\)
|                |                                                        |
|----------------+--------------------------------------------------------|
| \x             | expanded mode                                          |
| \l             | list all the databases that are present in the cluster |
| \c             | connect                                                |
| \l+ <database> |                                                        |
| \du            | list roles                                             |
| \du+           | same as above but more info                            |

**** psql prompt
|                                          |                |
|------------------------------------------+----------------|
| \i <file>                                | load file      |
| <statement> \g                           | same as ;      |
| \e <file> or \e <statement>              | open in editor |
| \h <command>                             | command doc    |
| \?                                       |                |
| \d                                       |                |
| postgresql://username@host:port/database |                |

*
** pg_ctl
|                          |                                                                                                                                          |
|--------------------------+------------------------------------------------------------------------------------------------------------------------------------------|
| start, stop, and restart | execute the corresponding actions on the cluster                                                                                         |
| status                   | reports the current status (running or not) of the cluster.                                                                              |
| initdb                   | executes the initialization of the cluster, possibly                                                                                     |
| reload                   | causes the PostgreSQL server to reload the configuration                                                                                 |
| promote                  |                                                                                                                                          |
| -d <database>            | Specifies the file system location of the database files                                                                                 |
| -m <mode>                | Specifies the shutdown mode. mode can be smart, fast, or immediate, or the first letter of one of these three. p, start, restart, reload |
| -U <user>                |                                                                                                                                          |
| -h <host>                | IPV4,IPV6 or hostname                                                                                                                    |
| -p                       | Specifies the location of the postgres executable.                                                                                       |
|                          |                                                                                                                                          |
** pstree
    - checkpointer
    - background writer
    - walwriter
    - stats collector
    - logical replication launcher
** initdb
** createdb
** createuser
#+begin_src shell
createuser -dPs doe
createuser -interactive wiki
#+end_src

* Terms
|              |                                                                                    |
|--------------+------------------------------------------------------------------------------------|
| session      |                                                                                    |
| transactions |                                                                                    |
| concurrency  |                                                                                    |
| ACID         | atomicity, consistency, isolation, and durability                                  |
| DMBS         | Database Management System                                                         |
| PID          | Process Identifier                                                                 |
| TableSpace   | tablespace is a storage space that can be outside the PGDATA directory             |
| PGDATA       |                                                                                    |
| postmaster   | prints out a few log lines before redirecting the logs to the appropriate log file |
| oid2name     |                                                                                    |
* Errors
#+begin_src shell
[error] Postgrex.Protocol (#PID<0.328.0>) failed to connect: ** (DBConnection.ConnectionError) tcp connect (localhost:5432): co
nnection refused - :econnrefused
#+end_src

* Running from CLI
** local and non-root database
#+begin_src shell-script
initdb -D .postgres -A md5 -U $USER --pwprompt
# or
initdb -D .postgres -A md5 -U $USER --pwfile=/path/to/passfile

pg_ctl -D .postgres -w start
createdb -U $USER mydb
#+end_src
** container from cli
#+begin_src sh
docker run --name postin -e POSTGRES_PASSWORD=postgres -p 5433:5432 -v pgdata:/var/lib/postgresql/data -d postgres:13
docker exec -it postin psql -d postgres -U postgres
#+end_src

#+begin_src shell
docker network create pgnetwork
docker run --name pg15beta1 --network pgnetwork -e POSTGRES_PASSWORD=whatever -d postgres:15beta1
docker run -it --rm --network pgnetwork postgres:15beta1 psql -h pg15beta1 -U postgres
#+end_src

** Container compose
#+begin_src yaml
version: "3.9"

services:
  database:
    image: postgres:latest
    restart: always
    env_file:
      - .env/development/database
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5442:5432"

volumes:
  db_data:
#+end_src



#+begin_src sql
create unlogged table if not exists categories (
pk int GENERATED ALWAYS AS IDENTITY
,title text NOT NULL
,description text
,PRIMARY KEY( pk )
,UNIQUE ( title )
);
#+end_src

* online tools
- https://mockaroo.com/
