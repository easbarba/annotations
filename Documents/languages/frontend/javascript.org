#+TITLE: EcmaScript

* Summary
    :PROPERTIES:
    :TOC:      :include all :depth 2 :ignore this
    :END:
  :CONTENTS:
  - [[#progress][Progress]]
    - [[#books][Books]]
    - [[#sloc][SLOC]]
    - [[#skills][SKills]]
  - [[#features][Features]]
    - [[#nubers][Nubers]]
  - [[#concepts][Concepts]]
  - [[#books][Books]]
    - [[#eloquent-javascript][Eloquent JavaScript]]
  - [[#sites][Sites]]
    - [[#web-js---misc][Web JS - Misc]]
    - [[#web-js---online-tools][Web JS - Online Tools]]
  - [[#frameworks][Frameworks]]
  - [[#refactoring][Refactoring]]
  - [[#articles][Articles]]
  - [[#interview][Interview]]
  :END:
* Progress
** Books
| Books                           | Cap    | @ |
|---------------------------------+--------+---|
| JavaScript The Definitive Guide | Arrays |   |
** SLOC
| Project   | folder                  | file         | @ |
|-----------+-------------------------+--------------+---|
| draggable | src/Draggable/DragEvent | DragEvent.js |   |
| inquirer  |                         |              |   |

* Base
** Types
- Types: numbers, strings, boolean, null, undefined, symbols
- Primitives: numbers, strings, boolean, null, undefined

*** Numbers
|   |           |
|---+-----------|
|   | primitive |
|   | immutable |

- Literals
#+begin_src js
0
3
100000 // or 1_000_000

// hexadecimal

0xff
0xBADCAFE

// ES6 added binary and octal
0b10101
0o377
#+end_src

- floating-point
[digits][.digits][(E|e)[(+|-)]digits]

#+begin_src js
r example:
3.14
2345.6789
.333333333333333333
6.02e23
1.4738223E-32
#+end_src

- Comparison
#+begin_src javascript
0 === -0 // true
1/0 === 1/-0 // false

NaN === NaN // false
Number.isNaN(NaN) // true

#+end_src

**** Arithmetic
- Underflow returns 0.
- underflow from a negative number, returns ‚Äúnegative zero.‚Äù
-
#+begin_src js
1 + 1
2 - 2
3 / 2
4 * 5
5 % 1

2 / 0 // Infinity or -  Infinity
0 / 0 // NaN
Infinity / Infinity // NaN
#+end_src
**** BigInt
- not to mix BigInt with regular number

#+begin_src js
1234n
0b111111n
0o7777n
0x8000000000000000n
BigInt()
#+end_src
*** Strings
|            |           |
|------------+-----------|
|            | primitive |
|            | immutable |
| empty      | 0         |
| UTF        | 16        |
| comparable | === / !== |
|            |           |

- arrays of characters
- In ES6, strings are iterable
- ES6 added backstick string
- ES5 allow break string lines w/ backslash '\'
- template literal: `meh ${foo}`
- tagged template literals
- pair of slashes constitutes a regular expression literal

#+begin_src js
'meh "xii"'

"foo \
'bar'"

`fo'o'
   "bar"`
'\n' // newline
'\xA9' // '¬©'
'\u{1f600}' // 'üòÄ'

'Hello ' + 'World' // 'Hello World'

String.raw`\n`.length

/^HTML/
/[1-9][0-9]*/

[..."1234"].forEach(x => console.log(x))
#+end_src
*** Boolean
|   |           |
|---+-----------|
|   | primitive |
|   | immutable |

- represents truth or falsehood
- falsy values: undefined, null, 0, -0, NaN, ""

#+begin_src js
a === 4 // true
true.toString() // 'true'
#+end_src

*** null
|   |               |
|---+---------------|
|   | primitive     |
|   | immutable     |
|   | no properties |
|   | no methods    |

- indicate the absence of a value
- is a object
- avoid using
- have no properties

#+begin_src js
typeof null // object

#+end_src
*** undefined
|   |               |
|---+---------------|
|   | primitive     |
|   | immutable     |
|   | no properties |
|   | no methods    |

- predefined global constant
- indicate the absence of a value
- the value of variables that have not been initialized,
- object property   or array element that does not exist,
- the return value of functions that do not explicitly return a value
- the value of function parameters for which no argument is passed.
- avoid using
- have no properties

#+begin_src js
typeof undefined // undefined
undefined === null // false
#+end_src

*** Symbols
|   |           |
|---+-----------|
|   | primitive |

- calling Symbol() twice with the same string produces two completely different Symbol values.

#+begin_src js
m = Symbol('meh')
typeof m // 'symbol'
#+end_src

**** methods
- Symbol
- Symbol.iterator
- toString()
- Symbol.for()
- Symbol.keyFor()
** Collection
*** Array
- is a object

**** conditional property access
#+begin_src js
a?.[index++]
#+end_src
**** methods
***** push
***** Array.from
ES6
***** toString
obtain a list of the array elements, themselves each converted to a string

*** Set
*** Map
** Operators
*** arithmethic
*** in
returns true if the specified property is in the specified object or its
prototype chain.
*** instance
 tests to see if the prototype property of a constructor appears anywhere in the
 prototype chain of an object. The return value is a boolean value.

- If the left-side operand ofinstanceof is not an object, instanceof returns false .
- If the righthand side is not a class of objects, it throws a TypeError .

#+begin_src js
let d = new Date();
d instanceof Date
d instanceof Object
d instanceof Number
let a = [1, 2, 3];
a instanceof Array
a instanceof Object
a instanceof RegExp

//Create a new object with the Date() constru
//=> true: d was created with Date()
//=> true: all objects are instances of Object
//=> false: d is not a Number object
//Create an array with array literal syntax
//=> true: a is an array
//=> true: all arrays are objects
//=> false: arrays are not regular expressions
#+end_src
*** miscellaneous
**** conditional operator (?:)
#+begin_src js
greeting = "hello " + (username ? username : "there");
#+end_src
**** typeof
- specifies the type of the operand.
#+begin_src js
(typeof value === "string") ? "'" + value + "'" : value.toString()
#+end_src
**** delete
- unary operator
- attempts to delete the object property or array element specified
- when a property is deleted, the property ceases to exist.
- expects its operand to be an lvalue
- in strict mode, delete raises a SyntaxError if its operand is an unqualified identifier

#+begin_src js
let o = { x: 1, y: 2};
delete o.x;

let a = [1,2,3];
delete a[2];

let o = {x: 1, y: 2};
delete o.x; // Delete one of the object properties; returns true.
typeof o.x;// Property does not exist; returns "undefined".
#+end_src
**** await
- only legal within functions that have been declared asynchronous with the async keyword.
- The value of the await operator is the fulfillment value of the Promise object.

**** First-Defined (??)
- short-circuiting
- irst operand is ‚Äúnullish‚Äù (i.e., null or undefined ) that this operator evaluates and returns the second operand
#+begin_src js
let max = maxWidth ?? preferences.maxWidth ?? 500;
#+end_src
**** void
- unary operator
- evaluates its operand, then discards the value and returns undefined
**** comma (,)
- evaluates its left operand, evaluates its right operand, and then returns the value of the right operand

** Expressions
*** Logical Expression
**** or
#+begin_src js
let max = maxWidth || preferences.maxWidth || 500;
#+end_src
**** not
- unary operator
- invert the boolean value of its operand
- always returns true or fals

#+begin_src js
// DeMorgan's Laws
!(p && q) === (!p || !q) // => true: for all values of p and q
!(p || q) === (!p && !q) // => true: for all values of p and q
#+end_src
*** Assignment Expression
- left-side operand to be an lvalue

**** let
- default value is undefined if not assigned

#+begin_src js
let meh = 'foo'
let i, sum;
#+end_src
**** Const
- same as let
- must initialized at declaration
- attempt to change its value throws a TypeError
- is a convention to declare constants with all capital letters

#+begin_src js
const FOO = 'bar'
const H0 = 74;
const C = 299792.458;
const AU = 1.496E8;
#+end_src
**** var
- do not have block scope
- outside of a function body, it declares a global variable.
- legal to declare the same variable multiple times with var
#+begin_src js
var x;
var data = [], count = data.length;
for(var i = 0; i < count; i++) console.log(data[i]);
#+end_src
**** destructuring assignment
- The number of variables on the left of a destructuring assignment does not have to match the number of array elements on the right.
- Extra variables on the left are set to undefined , and extra values on the right are ignored.
- The list of variables on the left can include extra commas to skip certain values on the right:
- ... to collect all unused or remaining values into a single variable when destructuring an array, before the last variable name

#+begin_src js
let [x,y] = [1,2];
[x,y] = [x+1,y+1];

let [x,y] = [1]; // x == 1; y == undefined
[x,y] = [1,2,3]; // x == 1; y == 2
[,x,,y] = [1,2,3,4]; // x == 2; y == 4

let [x, ...y] = [1,2,3,4]; // y == [2,3,4]
let [a, [b, c]] = [1, [2,2.5], 3]; // a == 1; b == 2; c == 2.5

let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0}; // A RGBA color
let {r, g, b} = transparent; // r == 0.0; g == 0.0; b == 0.0

let points = [{x: 1, y: 2}, {x: 3, y: 4}];// An array of two point objects
let [{x: x1, y: y1}, {x: x2, y: y2}] = points; // destructured into 4 variables.
(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // => true

let points = { p1: [1,2], p2: [3,4] };// An object with 2 array props
let { p1: [x1, y1], p2: [x2, y2] } = points;// destructured into 4 vars
(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // => true
#+end_src
*** eval
**** indirect
#+begin_src js
eval
#+end_src
**** direct
#+begin_src js
eval()
#+end_src
**** strict eval
- local eval with a private variable environment.
- not allowed to overwrite the eval() function with a new value.
- not allowed to declare a variable, function, function parameter, or catch block parameter with the name ‚Äúeval‚Äù
** Statements
*** Expression
#+begin_src js
greeting = "Hello " + name;
i *= 3;
#+end_src
*** block
- does not end with a semicolon
#+begin_src js
{
    x = Math.PI;
    cx = Math.cos(x);
    console.log("cos(œÄ) = " + cx);
}
#+end_src
*** empty
- allows you to include no statements where one is expected.
#+begin_src js
;
#+end_src
*** conditionals
**** if
*** loops
**** while
**** do/while
**** for
**** for/await
**** for/of
- requires an iterable object
- ES6
- favor it for arrays

**** for/in
- works with any object after the in.
- loops through the property names of a specified object.
- If it evaluates to null or undefined , the interpreter skips the loop and moves on to the next statement.
- pre-ES6, may be a source of bugs with ES6 additions
*** with
runs a block of code as if the properties of a specified object were variables
in scope for that code.

- forbidden in strict mode, avoid using it whenever possible.
- creates a temporary scope with the properties of object as variables and then executes statement within that scope.
- const or let or var to declare a variable or constant within the body of a
  with statement, it creates an ordinary variable and does not define a new
  property within the specified object.

#+begin_src js
with (object)
    statement
#+end_src

#+begin_src js
let f = document.forms[0];
f.name.value = "";
f.address.value = "";
f.email.value = "";

with(document.forms[0]) {
// Access form elements directly here. For example:
  name.value = "";
  address.value = "";
  email.value = "";
}
#+end_src
*** debugger

** Objects
- mutable
- not comparable
- reference type
- parentheses can be omitted if no arguments are passed to the constructor
- unordered collection of properties
- inherits from prototype
- three property attributes(writable,enumerable,configurable)
- almost all objects have a prototype, but only a relatively small number of objects have a prototype property.
- In order to make an object iterable (so it can be used with a for/of loop), you must define a method with the symbolic name Symbol.iterator

*** Literal
is an expression that creates and initializes a new and distinct object
each time it is evaluated.

#+begin_src js
let empty = {};
let point = { x: 0, y: 0 };
let p2 = { x: point.x, y: point.y+1 };
let book = {
  "main title": "JavaScript",
  "sub-title": "The Definitive Guide",
  for: "all audiences",
  author: {
    firstname: "David",
    surname: "Flanagan"
  }
};

Object.create()
#+end_src

*** new
#+begin_src js
let o = new Object();
let a = new Array();
let d = new Date();
let r = new Map();
#+end_src

*** usage

#+begin_src js
let author = book.author; // Get the "author" property of the book.
let name = author.surname; // Get the "surname" property of the author.
let title = book["main title"]; // Get the "main title" property of the book.

let o = { x: 1 }, p = { x: 1 };
o === p // false

let x = o;
o == x // true

o.x = 2; // change value
o.y = 3; // add

let rectangle = {
    upperLeft: { x: 2, y: 2 },
    lowerRight: { x: 4, y: 5 }
};

o =  new Object()
o =  new Object // same
o.x = 'meh' // {x: 'meh'}

let author = book.author; // Get the "author" property of the book.
let name = author.surname; // Get the "surname" property of the author.
let title = book["main title"]; // Get the "main title" property of the book.

book.edition = 7; // Create an "edition" property of book.
book["main title"] = "ECMAScript"; // Change the "main title" property.

o = {...defaults, ...o};
#+end_src

*** Global Object
- the properties of this object are the globally defined identifiers that are available to a JavaScript program.
- global constants like undefined , Infinity , and NaN
- global functions like isNaN() , parseInt(), and eval()
- constructor functions like Date() , RegExp() , String() , Object() , and Array()
- global objects like Math and JSON
**** properties
- global
- globalThis
*** query and set
- not an error to query a property that does not exist
- It is an error, however, to attempt to query a property of an object that does not exist.
- Attempting to set a property on null or undefined also causes a TypeError.
- In strict mode, a TypeError is thrown whenever an attempt to set a property fails.

#+begin_src js
let unitcircle = { r: 1 };
let c = Object.create(unitcircle);
c.x = 1; c.y = 1;
c.r = 2;
unitcircle.r
#+end_src

query w/ guard anti-undefined

#+begin_src js
let surname = undefined;
if (book) {
    if (book.author) {
        surname = book.author.surname;
    }
}

// A concise and idiomatic alternative to get surname or null or undefined
surname = book && book.author && book.author.surname;

let surname = book?.author?.surname;
#+end_src
*** extend

ES6 - Shorthand Properties

#+begin_src js
let x = 1,
  y = 2;
let o = {
  x: x,
  y: y,
};

// ES6

let x = 1, y = 2;
let o = { x, y };
o.x + o.y // => 3
#+end_src

Computed Property Names

#+begin_src js
const PROPERTY_NAME = "p1";
function computePropertyName() { return "p" + 2; }

let o = {};
o[PROPERTY_NAME] = 1;
o[computePropertyName()] = 2;

const PROPERTY_NAME = 'p1';
function computePropertyName() {
  return 'p' + 2;
}

let p = {
  [PROPERTY_NAME]: 1,
  [computePropertyName()]: 2,
};

p.p1 + p.p2; // => 3
#+end_src

*Symbols as Property Names*
- In ES6 and later, property names can be strings or symbols.

#+begin_src js
const extension = Symbol('my extension symbol');
let o = {
  [extension]: {
    /* extension data stored in this object */
  },
};
o[extension].x = 0; // This won't conflict with other properties of o
#+end_src

*Spread Operator*

#+begin_src js
let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.y + rect.width + rect.height // => 175

let o = { x: 1 };
let p = { x: 0, ...o };
p.x // => 1: the value from object o overrides the initial value
let q = { ...o, x: 2 };
q.x // => 2: the value 2 overrides the previous value from o.
#+end_src

*Shorthand Methods*

pre-ES6

#+begin_src js
let square = {
  area: function () {
    return this.side * this.side;
  },
  side: 10,
};
square.area(); // => 100
#+end_src

ES6
- function keyword and the colon can be omitted
- can also use string literals and computed property names

#+begin_src js
let square = {
  area() {
    return this.side * this.side;
  },
  side: 10,
};
square.area(); // => 100

const METHOD_NAME = 'm';
const symbol = Symbol();
let weirdMethods = {
  'method With Spaces'(x) {
    return x + 1;
  },
  [METHOD_NAME](x) {
    return x + 2;
  },
  [symbol](x) {
    return x + 3;
  },
};
weirdMethods['method With Spaces'](1); // => 2
weirdMethods[METHOD_NAME](1); // => 3
weirdMethods[symbol](1); // => 4
#+end_src

*Property Getters and Setters*

- queries the value of an accessor property, JavaScript invokes the getter method (passing no arguments)
- if it has only a getter method, it is a read-only property.
- if it has only a setter method, it is a write-only property

#+begin_src js
let o = {
  // An ordinary data property
  dataProp: value,

  // An accessor property defined as a pair of functions.
  get accessorProp() {
    return this.dataProp;
  },
  set accessorProp(value) {
    this.dataProp = value;
  },
};
#+end_src

#+begin_src js
let p = {
  // x and y are regular read-write data properties.
  x: 1.0,
  y: 1.0,

  // r is a read-write accessor property with getter and setter.
  // Don't forget to put a comma after accessor methods.
  get r() {
    return Math.hypot(this.x, this.y);
  },
  set r(newvalue) {
    let oldvalue = Math.hypot(this.x, this.y);
    let ratio = newvalue / oldvalue;
    this.x *= ratio;
    this.y *= ratio;
  },

  // theta is a read-only accessor property with getter only.
  get theta() {
    return Math.atan2(this.y, this.x);
  },
};
p.r; // => Math.SQRT2
p.theta; // => Math.PI / 4

let q = Object.create(p); // A new object that inherits getters and setters
q.x = 3; q.y = 4; // Create q's own data properties
q.r // => 5: the inherited accessor properties work
q.theta // => Math.atan2(4, 3)
#+end_src

Other reasons to use accessor properties include sanity checking of property
writes and returning different values on each property read

#+begin_src js

// This object generates strictly increasing serial numbers
const serialnum = {
  // This data property holds the next serial number.
  // The _ in the property name hints that it is for internal use only.
  _n: 0,
  // Return the current value and increment it
  get next() {
    return this._n++;
  },
  // Set a new value of n, but only if it is larger than current
  set next(n) {
    if (n > this._n) this._n = n;
    else throw new Error('serial number can only be set to a larger value');
  },
};

serialnum.next = 10; // Set the starting serial number
serialnum.next; // => 10
serialnum.next; // => 11: different value each time we get next
#+end_src

#+begin_src js
// This object has accessor properties that return random numbers.
// The expression "random.octet", for example, yields a random number
// between 0 and 255 each time it is evaluated.
const random = {
  get octet() {
    return Math.floor(Math.random() * 256);
  },
  get uint16() {
    return Math.floor(Math.random() * 65536);
  },
  get int16() {
    return Math.floor(Math.random() * 65536) - 32768;
  },
};
#+end_src

*** delete
- only deletes own properties, not inherited ones.
- To delete an inherited property, you must delete it from the prototype object in which it is defined.
  Doing this affects every object that inherits from that prototype
- evaluates to true if the delete succeeded or if the delete had no effect (such as deleting a nonexistent property)
- evaluates to true when used (meaninglessly) with an expression that is not a property access expression
- does not remove properties that have a configurable attribute of false .
- In strict mode, delete raises a SyntaxError if its operand is an unqualified identifier like x ,
  and you have to be explicit about the property access
- in non-strict mode, can omit the reference to the global object and simply follow the delete operator with the property name:
#+begin_src js
let o = {x: 1}; // o has own property x and inherits property toString
delete o.x // => true: deletes property x
delete o.x // => true: does nothing (x doesn't exist) but true anyway
delete o.toString // => true: does nothing (toString isn't an own property)
delete 1 // => true: nonsense, but true anyway


// In strict mode, all these deletions throw TypeError instead of returning false
delete Object.prototype // => false: property is non-configurable
var x = 1; // Declare a global variable
delete globalThis.x // => false: can't delete this property
function f() {} // Declare a global function
delete globalThis.f // => false: can't delete this property either
#+end_src

*** testing properties
- strings or symbols as property names
- propertyIsEnumerable() returns true only if the named property is an own property and its enumerable attribute is true.
- in can distinguish between properties that do not exist and properties that exist but have been set to undefined.

#+begin_src js
let o = { x: 1 };
"x" in o // => true: o has an own property "x"
"y" in o // => false: o doesn't have a property "y"
"toString" in o // => true: o inherits a toString property


let o = { x: 1 };
o.hasOwnProperty("x") // => true: o has an own property x
o.hasOwnProperty("y") // => false: o doesn't have a property y
o.hasOwnProperty("toString") // => false: toString is an inherited property

let o = { x: 1 };
o.propertyIsEnumerable("x") // => true: o has an own enumerable property x

o.propertyIsEnumerable("toString") // => false: not an own property
Object.prototype.propertyIsEnumerable("toString") // => false: not enumerable

let o = { x: 1 };
o.x !== undefined
// => true: o has a property x
o.y !== undefined
// => false: o doesn't have a property y
o.toString !== undefined // => true: o inherits a toString property


let o = { x: undefined };
o.x !== undefined
o.y !== undefined
"x" in o
"y" in o
delete o.x;
"x" in o
// Property is explicitly set to undefined
// => false: property exists but is undefined
// => false: property doesn't even exist
// => true: the property exists
// => false: the property doesn't exist
// Delete the property x
// => false: it doesn't exist anymore







#+end_src

*** conditional property access
- guard against errors
#+begin_src js
let a = { b: null };
a.b?.c.d // => undefined
#+end_src
*** methods
**** Object.values
#+begin_src js
let sum = 0;
for(let v of Object.values(o)) {
sum += v;
}
sum // => 6
#+end_src
**** Object.seal
**** toString
- takes no arguments

#+begin_src js
let s = { x: 1, y: 1 }.toString();
// s == "[object Object]"

let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
};
String(point);
// => "(1, 2)": toString() is used for string conversions
#+end_src
**** toLocaleString
- return a localized string representation of the object

#+begin_src js
let point = {
  x: 1000,
  y: 2000,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
  toLocaleString: function () {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  },
};
point.toString(); // => "(1000, 2000)"
point.toLocaleString(); // => "(1,000, 2,000)": note thousands separators
#+end_src
**** valueOf
to convert an object to some primitive type other than a string, typically, a number.

- called automatically if an object is used in a context where a primitive value is required.
- defining valueOf() to convert to numbers allows objects to be compared with < and >

#+begin_src js
let point = {
  x: 3,
  y: 4,
  valueOf: function () {
    return Math.hypot(this.x, this.y);
  },
};
Number(point); // => 5: valueOf() is used for conversions to numbers
point > 4; // => true
point > 5; // => false
point < 6; // => true
#+end_src
**** toJSON
JSON.stringify() method (see ¬ß6.8) looks for a toJSON() method on any object it is asked to serialize.

#+begin_src js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
  toJSON: function () {
    return this.toString();
  },
};
JSON.stringify([point]); // => '["(1, 2)"]'

#+end_src
**** Object.freeze
**** __proto__
#+begin_src js
o1.__proto__ // { x: 1, y: 2 }
#+end_src
**** Object.assign
**** Object.keys
#+begin_src js
let o = { x: 1, y: 2, z: 3 };
let keys = "";
for(let k of Object.keys(o)) {
keys += k;
}
keys // => "xyz"
#+end_src
**** Object.entries
#+begin_src js
let pairs = "";
for(let [k, v] of Object.entries(o)) {
pairs += k + v;
}
pairs // => "x1y2z3"
#+end_src
**** Object.create()
- passing null to create a new object the newly created object will not inherit anything.
- create an empty object by passing a Object.prototype
- also takes an optional second argument that describes the properties of the new object.

#+begin_src js
let o1 = Object.create({x: 1, y: 2});
o1.x + o1.y

let o2 = Object.create(null); // o2 inherits no props or methods.
o2.toString() // Uncaught TypeError: o2.toString is not a function

let o3 = Object.create(Object.prototype); // empty object  like {} or new Object().

let o = { x: "don't change this value" };
library.function(Object.create(o)); // Guard against accidental modifications
#+end_src

*** prototypes
#+begin_src js
Object.prototype
#+end_src
** Functions
- is an object
- obtain the source code for the function

#+begin_src js
function meh() { return 'meh' }
meh // [Function: meh]
meh() // 'meh'



#+end_src
*** Template tag functions
*** Conditional Invocation
- if the expression to the left of the ?. evaluates to null or undefined , then
  the entire invocation expression evaluates to undefined and no exception is
  thrown.
- if the value to the left of ?. is null or undefined , then none of the
  argument expressions within the parentheses are evaluated
#+begin_src js
function square(x, log) {
    log?.(x);
    return x * x;
}
#+end_src
*** yield
- only in ES6 generator functions
** Errors
*** throw

#+begin_src js
throw expression;
#+end_src
*** Error
**** new
#+begin_src js
e = new Error('Oooops!')
#+end_src

#+begin_src js
function CustomError(foo, message, fileName, lineNumber) {
  var instance = new Error(message, fileName, lineNumber);
  instance.name = 'CustomError';
  instance.foo = foo;
  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, CustomError);
  }
  return instance;
}

CustomError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});

if (Object.setPrototypeOf){
  Object.setPrototypeOf(CustomError, Error);
} else {
  CustomError.__proto__ = Error;
}

try {
  throw new CustomError('baz', 'bazMessage');
} catch(e){
  console.error(e.name); //CustomError
  console.error(e.foo); //baz
  console.error(e.message); //bazMessage
}
#+end_src
**** properties
***** stack
a multi-line string that contains a stack trace of the JavaScript call stack at
the moment that the Error object was created.
***** name
#+begin_src js
try {
  throw new Error('Oooops!');
} catch (e) {
  console.log(e.name + ': ' + e.message);
}
#+end_src
***** message
#+begin_src js
try {
  throw new Error('Oooops!');
} catch (e) {
  console.log(e.name + ': ' + e.message);
}
#+end_src
**** methods
***** toString
returns the value of the
name property followed by a colon and space and the value of the message property
**** Subclasses
***** EvalError
***** RangeError
***** ReferenceError
***** SyntaxError
***** TypeError
***** URIError
**** Examples
#+begin_src js
class HTTPError extends Error {
  constructor(status, statusText, url) {
    super(`${status} ${statusText}: ${url}`)
    this.status = status
    this.statusText = statusText
    this.url = url
  }
  get name() {
    return 'HTTPError'
  }
}
#+end_src
*** exceptions
exceptions are thrown whenever a runtime error occurs and whenever the program
explicitly throws one using the throw statement.
*** try/catch/finally
- catch and finaly are optional but one must be present
- variable in catch
- value associated with the exception (an Error object, for example) is assigned to this parameter.

#+begin_src js
try {
// Ask the user to enter a number
let n = Number(prompt("Please enter a positive integer", ""));
// Compute the factorial of the number, assuming the input is valid
let f = factorial(n);
// Display the result
alert(n + "! = " + f);
}
catch(ex) {
// If the user's input was not valid, we end up here
alert(ex); // Tell the user what the error is
}
#+end_src
Simulate *for* in a *while* w/ the aid of try/catch
#+begin_src js
// Simulate for(initialize ; test ;increment ) body;
initialize ;
while( test ) {
try { body ; }
finally { increment ; }
}
#+end_src

Bare catch
#+begin_src js
function parseJSON(s) {
try {
return JSON.parse(s);
} catch {
// Something went wrong but we don't care what it was
return undefined;
}
}
#+end_src
** Modes
*** Strict mode
- attempt to use an undeclared variable gets a reference error
- ES5 directive
- can appear only at the start of a script or at the start of a function body
- scope where is set get strict: global, function, module, class

#+begin_src js
"use strict";
#+end_src
*** Non-stric
- attempt to use an undeclared variable ends up creating a new global variable.


Asynchronous Control Flow Patterns with Promises and Async Await
* Concepts
** Hoisting
** Import/Export
*** AMD
Asynchronous Module Definition

- imports modules asynchronously (hence the name).
- is made for frontend (when it was proposed) (while CJS backend).
- syntax is less intuitive than CJS. I think of AMD as the exact opposite sibling of CJS.


#+begin_src js
define(['dep1', 'dep2'], function (dep1, dep2) {
    //Define the module value by returning a value.
    return function () {};
});
#+end_src

#+begin_src js
// "simplified CommonJS wrapping" https://requirejs.org/docs/whyamd.html
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');
    return function () {};
});
#+end_src

*** UMD
Universal Module Definition

- Works on front and back end (hence the name universal).
- Unlike CJS or AMD, UMD is more like a pattern to configure several module systems. Check here for more patterns.
- UMD is usually used as a fallback module when using bundler like Rollup/ Webpack


#+begin_src js
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery", "underscore"], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"), require("underscore"));
    } else {
        root.Requester = factory(root.$, root._);
    }
}(this, function ($, _) {
    // this is where I defined my module implementation

    var Requester = { // ... };

    return Requester;
}));
#+end_src

*** CJS
- Some of you may immediately recognize CJS syntax from node. That's because node uses CJS module format.
- CJS imports module synchronously.
- You can import from a library node_modules or local dir. Either by const
  myLocalModule = require('./some/local/file.js') or var React =
  require('react'); works.
- When CJS imports, it will give you a copy of the imported object.
- CJS will not work in the browser. It will have to be transpiled and bundled.

#+begin_src js
//importing
const doSomething = require('./doSomething.js');

//exporting
module.exports = function doSomething(n) {
  // do something
}

#+end_src
*** ESM
** Transpiling
 a portmanteau of /trans/lating and /com/piling

* Library
** Numbers
- do not accept BigInt

#+begin_src js
Number.NEGATIVE_INFINITY
-Number.MAX_VALUE * 2
Number.NaN
Number.MIN_VALUE/2
-Number.MIN_VALUE/2
Number.parseInt()
Number.parseFloat()
Number.isNaN(x)
Number.isFinite(x)
Number.isInteger(x)
Number.isSafeInteger(x)
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
Number.EPSILON
#+end_src
** RegExp
- constructor function
*** Date
** Error
- constructor function
** Date
- constructor function
** JSON
- Objects, arrays, strings, finite numbers, true , false , and null are supported and can be serialized and restored.
- NaN , Infinity , and -Infinity are serialized to null

#+begin_src js
let o = {x: 1, y: {z: [false, null, ""]}}; // Define a test object
let s = JSON.stringify(o); // s == '{"x":1,"y":{"z":[false,null,""]}}'
let p = JSON.parse(s); // p == {x: 1, y: {z: [false, null, ""]}}
#+end_src
*** JSON.stringify
*** JSON.parse
