#+TITLE: Terraform

* Summary
:PROPERTIES:
:TOC:      :include all
:END:
:CONTENTS:
- [[#summary][Summary]]
- [[#progress][Progress]]
  - [[#books][Books]]
- [[#base][Base]]
  - [[#features][Features]]
  - [[#resouces][resouces]]
    - [[#ami][ami]]
    - [[#instance_type][instance_type]]
    - [[#tags][tags]]
    - [[#data][data]]
    - [[#local][local]]
  - [[#terraform][terraform]]
  - [[#expression][expression]]
    - [[#for][for]]
    - [[#conditional-expressionternary][conditional expression(ternary)]]
    - [[#splat][splat]]
  - [[#modules][modules]]
    - [[#minimal-structure][minimal structure]]
  - [[#output][output]]
  - [[#variables][variables]]
  - [[#data][data]]
    - [[#archive_file][archive_file]]
  - [[#locals][locals]]
  - [[#types][types]]
    - [[#string][string]]
    - [[#number][number]]
    - [[#list][list]]
    - [[#bool][bool]]
    - [[#map][map]]
  - [[#functions][functions]]
    - [[#join][join]]
    - [[#tolist][tolist]]
    - [[#fileset][fileset]]
    - [[#templatefile][templatefile]]
    - [[#count][count]]
  - [[#misc][misc]]
    - [[#splat][splat]]
  - [[#lifecycle][lifecycle]]
- [[#commands][Commands]]
  - [[#--options][--options]]
    - [[#-var][-var]]
  - [[#apply][apply]]
  - [[#console][console]]
  - [[#refresh][refresh]]
  - [[#destroy][destroy]]
  - [[#fmt][fmt]]
  - [[#graph][graph]]
  - [[#output][output]]
  - [[#plan][plan]]
    - [[#options][options]]
  - [[#show][show]]
  - [[#state][state]]
    - [[#list][list]]
  - [[#refresh][refresh]]
- [[#files][Files]]
  - [[#tfvars][.tfvars]]
  - [[#tf][.tf]]
  - [[#terraformtfstate][terraform.tfstate]]
:END:

* Progress
** Books
| Books               | chapter                | @ |
|---------------------+------------------------+---|
| Terraform in Action | 5 Serverless made easy |   |

* Base
** Features
- IaC
- declarative
- mainly provisioning
- can deploy apps
- no meant for management
- more advanced in orchestration
- better for infrastructure

** resouces
*** ami
The Amazon Machine Image (AMI) to run on the EC2 Instance.
*** instance_type
The type of EC2 Instance to run.
*** tags
*** data
*** local
** terraform
special configuration block responsible for configuring Terraform
** expression
 anything that returns a value.
*** for
#+begin_src shell
[for i, v in var.list : "${i} is ${v}"]
[for k, v in var.map : length(k) + length(v)]
{for s in var.list : s => upper(s)}
[for s in var.list : upper(s) if s != ""]
#+end_src

#+begin_src terraform
{for k,v in var.words : k => v }
[for s in v : upper(s)]
{for k,v in var.words : k => [for s in v : upper(s)] if k != "numbers"}
#+end_src
*** conditional expression(ternary)
#+begin_src terraform
locals {
  v = length(var.words["nouns"])>=1 ? var.words["nouns"] : [][0]
}
#+end_src
*** splat
** modules
*** minimal structure
- main.tf
- outputs.tf
- variables.tf
- terraform.tfvars
- providers.tf
- versions.tf
- README.md

** output
#+begin_src hcl
output "container_name" {
  value = docker_contianer.my_container.name
  description = "My container name"
}
#+end_src
** variables
- command line (-var option),
- via a file (-var-file option)
- if there is no default value, terraform prompts for one.
- environment variables of the name TF_VAR_<variable_name> will be used.

#+begin_src hcl
variable "image_id" {
  type = string
}

variable "availability_zone_names" {
  type    = list(string)
  default = ["us-west-1a"]
}

variable "docker_ports" {
  type = list(object({
    internal = number
    external = number
    protocol = string
  }))
  default = [
    {
      internal = 8300
      external = 8300
      protocol = "tcp"
    }
  ]
}
#+end_src

#+begin_src shell
terraform plan -var "server_port=8080"

export TF_VAR_server_port=8080 && terraform plan
#+end_src

sensitive variables

#+begin_src hcl
variable "user_information" {
  type = object({
    name    = string
    address = string
  })
  sensitive = true
}

resource "some_resource" "a" {
  name    = var.user_information.name
  address = var.user_information.address
}

#+end_src
** data
*** archive_file
#+begin_src terraform
data "archive_file" "mad_libs" {
  depends_on  = [local_file.mad_libs]
  type        = "zip"
  source_dir  = "${path.module}/madlibs"
  output_path = "${path.cwd}/madlibs.zip"
}
#+end_src

** locals
#+begin_src terraform
locals {
  uppercase_words = {for k, v in var.words : k => [for s in v : upper(s)]}
}

resource "random_shuffle" "random_nouns" {
  input = local.uppercase_words["nouns"]
}
#+end_src
** types
*** string

interpolation

#+begin_src terraform
"Hello, ${var.name}!"
 %{ for ip in var.list.*.ip }
server ${ip}
%{ endfor }
#+end_src
*** number
*** list
#+begin_src hcl
[1, 2, 3]
["a", "b", "c"]
#+end_src
*** bool
*** map
#+begin_src hcl
default = {
key1 = "value1"
key2 = "value2"
key3 = "value3"
}
#+end_src

** functions
*** join
*** tolist
*** fileset
*** templatefile
*** count
references current value

#+begin_src terraform
count.index
#+end_src
** misc
*** splat
container_name[*]
** lifecycle
* Commands
** --options
*** -var
** apply
relates or updates infrastructure according to Terraform configuration
files in the current directory.

By default, Terraform will generate a new plan and present it for your
approval before taking any action. You can optionally provide a plan
file created by a previous call to "terraform plan", in which case
Terraform will take the actions described in that plan without any
confirmation prompt.

- execute plan

|                |   |
|----------------+---|
| --auto-approve |   |
** console
** refresh
Update the state file of your infrastructure with metadata that matches
the physical resources they are tracking.

This will not modify your infrastructure, but it can modify your
state file to update metadata. This metadata might cause new changes
to occur when you generate a plan or call apply next.

 - does not modify managed existing infrastructure, just Terraform state

** destroy
Destroy Terraform-managed infrastructure.

This command is a convenience alias for:
    terraform apply -destroy

- destroy resources/infrastructure
- remove one by one
- clean up resources
** fmt
** graph
** output
 Reads an output variable from a Terraform state file and prints
  the value. With no additional arguments, output will display all
  the outputs for the root module.  If NAME is not specified, all
  outputs are printed.
** plan
- create an execution plan

*** options
|                 |   |
|-----------------+---|
| --out=PLAN_NAME |   |
** show
#+begin_src shell
terraform show -json plan.out > plan.json
#+end_src
** state
*** list
** refresh
- get from provider current state
* Files
** .tfvars
** .tf
** terraform.tfstate

