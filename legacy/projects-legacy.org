#+TITLE: Personal Projects Legacy files

* Dot
** golang
#+begin_src golang
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	root := flag.String("deploy", "", "deploy dotfiles links")
	force := flag.Bool("force", false, "force redeployment of dotfiles links")
	flag.Parse()

	if *root == "" {
		flag.Usage()
		os.Exit(1)
	}

	ignore, err := ioutil.ReadFile(filepath.Join(*root, ".dotsignore"))

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fixed_ignored := strings.Split(string(ignore), "\n")
	fixed_root := filepath.Clean(*root)
	crawler(fixed_root, fixed_ignored, *force)
}

func crawler(root string, ignored []string, force bool) {
	filepath.Walk(root,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				fmt.Println(err)
				return err
			}

			// check if it is to ignore file
			if filterOut(root, ignored) {
				return nil
			}

			linkFile(path, force)
			return nil
		})

	println("")
	fmt.Println("Ignored: ", ignored)
	fmt.Print("Root: ", root)
}

// ignore file if its is in .dotsignored
func filterOut(root string, ignored []string) bool {
	for _, item := range ignored {
		rooted_item := filepath.Join(root, item)
		if item == "" || strings.HasPrefix(root, rooted_item) {
			return true
		}
	}

	return false
}

func linkFile(path string, force bool) {
	if force {
		fmt.Print("Forcing re-linking")
	}

	// finally, print file to be linked
	fmt.Println(path)
}

#+end_src
** perl
#+begin_src perl
#!/usr/bin/perl -w

use v5.32;
use utf8;
use warnings;
use strict;
use Getopt::Long 'HelpMessage';
use Time::Piece;

# CLI PARSER

GetOptions(
    'from=s' => \my $from_name,
    'to=s' => \(my $to_name = '/home/'),
    'deploy' => \(my $deploy = 0),
    'pretend' => \(my $pretend = 0),
    'overwrite' => \(my $overwrite = 0),
    'info' =>  sub { say info() },
    'help' => sub { HelpMessage(0) }
) or HelpMessage(1);

die "\nFROM folder is required (--to)\n" unless $from_name;

# die unless we got the mandatory argument
HelpMessage(1) unless $from_name;

sub info
{
    return "-- general information --
from:
to: $to_name
deploy: $deploy
pretend: $pretend
overwrite: $overwrite"
}


# tbc
sub print_license { ... }

=head1 NAME

license - get license texts at the command line!

=head1 SYNOPSIS

  --from,-f        folder with dotfiles (required)
  --to,-to         location where to link files (defaults to $HOME)
  --pretend,-p     mimic deployment of symbolic links
  --deploy,-d      deploy dotfiles links
  --overwrite,-o   force redeployment of dotfiles links
  --info,-i        general information of internals commands
  --help,-h        Print this help

=head1 VERSION

0.01

=cut
#+end_src
** elixir
#+begin_src elixir
#! /usr/bin/env elixir

# Description: An opitionated dotfile deployer base on guix home and nix homemanager.

# Features:
# - the dotsignore file at the folder root behaves just like git's one ignoring undesired dotfiles.
# - Folders are not symlinked but created.
# - dry-run mode
# - remove faulty symlinks if found
# - backup non-symlink files to $HOME/.backup
# - fully implemented cli interface
# - GNU-Linux/BSD distros only

# TODO: walk through directories and perform actions per folder
# TODO: Accept git commit sha as source to symlink deployment.
# TODO: Read-only symlinks.
# TODO: dotsignore to accept hash-like folder. eg: .config{foo,bar,meh,forevis}
# TODO: set minimal permission to 0744

defmodule Dots do
  defp ignored(root, {:ok, files}) do
    File.stream!(files)
    |> Enum.map(&String.trim(&1))
    |> Enum.concat([".dotsignore"])
    |> Enum.map(&Path.join(root, &1))
    |> MapSet.new()
  end

  defp ignored(_root, {:error, nil}) do
    []
  end

  defp ignored_exist?(root) do
    root = Path.join(root, ".dotsignore")
    if File.exists?(root), do: {:ok, root}, else: {:error, nil}
  end

  defp ignore_me?(root, item) do
    ignored(root, ignored_exist?(root))
    |> Enum.any?(&String.starts_with?(item, &1))
  end

  def ls_r(path) do
    cond do
      File.regular?(path) ->
        [path]

      File.dir?(path) ->
        File.ls!(path)
        |> Enum.map(&Path.join(path, &1))
        |> Enum.map(&ls_r/1)
        |> Enum.concat()

      true ->
        []
    end
  end

  def run(root) do
    items = ls_r(root)

    for item <- items do
      unless ignore_me?(root, item) do
        target = item
        link_name = to_home(item, root)

        make_folder(link_name)
        link_file(target, link_name)
      end
    end
  end

  def to_home(item, root) do
    # /data/dots/.config/mpd/mpd.conf to $HOME/.config/mpd/mpd.conf
    String.replace(item, root, System.user_home())
  end

  def make_folder(link_name) do
    link_dir = Path.dirname(link_name)

    unless File.exists?(link_dir) do
      File.mkdir_p!(link_dir)
    end
  end

  def link_file(target, link_name) do
    unless File.exists?(link_name) do
      IO.puts("#{target} -> #{link_name}")
      File.ln_s!(target, link_name)
    end
  end

  def deploy(root) do
    run(root)
  end

  def pretend(root) do
    IO.puts("pretend-mode")
    IO.inspect(root)
  end

  def info(root) do
    IO.puts("root: #{root}")
  end
end

defmodule CLI do
  def main(args) do
    args
    |> OptionParser.parse(
      switches: [deploy: :string, pretend: :string, help: :boolean],
      aliases: [D: :deploy, P: :pretend, H: :help]
    )
    |> elem(0)
    |> run()
  end

  def help do
    IO.puts("Usage: dots [options]
  -D, --deploy                    symlink all dotfiles
  -P, --pretend                   pretend to symlink all dotfiles
  -H, --help                      cli options information")

    System.halt(0)
  end

  def run(deploy: root) do
    root = Path.dirname(IO.chardata_to_string(root))
    Dots.deploy(root)
  end

  def run(pretend: root) do
    root = Path.dirname(IO.chardata_to_string(root))
    Dots.pretend(root)
  end

  def run(help: true) do
    help()
  end

  def run(_) do
    help()
  end
end

CLI.main(System.argv())

#+end_src
* Cejo
** Ruby
     #+begin_src ruby
     def get_name_files(folder)
       name = folder.to_path
       files = []

       folder.children.each do |f|
	 files << f if f.file?
       end

       { name => files }
     end

     def prepare_folders
       Find.find(a) do |f|
	 next if f.start_with? a.join('.git').to_path # ignore .git folder

	 x = Pathname.new f
	 puts x.parent.to_path
       end

       # result = {}

       # SOURCE_FOLDER.children.each do |f|
       #   next unless f.basename.to_s != '.git' && f.directory?

       #   x = get_name_files f
       #   result[x.keys.first] = x.values
       # end

       # result
     end

     #+end_src
** .NET
*** Projects
      #+begin_src csharp
      using System.Collections.Generic;
      using System.IO;

      using Cero.Services;

      namespace Cero.Sections.Projects
      {
	  /// <summary>
	  ///  A set of values used to specify a project information to start.
	  /// </summary>
	  public class Cpython : IProject
	  {
	      private readonly Folders _folders;
	      private readonly Git _git;
	      private readonly Runners _runners;

	      public Cpython(Folders folders, Git git, Runners runners) =>
		  (_folders, _git, _runners) = (folders, git, runners);

	      ProjectInfo Info() => new ProjectInfo()
	      {
		  Name = "cpython",
		  Url = "https://github.com/python/cpython",
		  Folder = Path.Join(_folders.Builds, "cpython"),
		  Tag = "v3.8.2",
		  Commands = new List<(string, string)>
		  {                ("mkdir", "-pv build"),
		      ("make", "distclean"),
		      ("sh", $@"configure --prefix={ _folders.Local } --enable-optimizations --with-lto --with-pydebug"),
		      ("make", "-s"),
		      ("make", "-j2 install"),
		  }
	      };

	      public void Start() =>
		  new ProjectBuilder(_git, _runners, Info()).Build();
	  }
      }


      using System.Collections.Generic;
      using System.IO;

      using Cero.Services;

      namespace Cero.Sections.Projects
      {
	  /// <summary>
	  ///  A set of values used to specify a project information to start.
	  /// </summary>
	  public class Nyxt : IProject
	  {
	      private readonly Folders _folders;
	      private readonly Git _git;
	      private readonly Runners _runners;

	      public Nyxt(Folders folders, Git git, Runners runners) =>
		  (_folders, _git, _runners) = (folders, git, runners);


	      ProjectInfo Info() => new ProjectInfo()
	      {
		  Name = "nyxt",
		  Url = "https://github.com/atlas-engineer/nyxt",
		  Folder = Path.Join(_folders.Builds, "nyxt"),
		  Commands = new List<(string, string)>
		  {
		      ("make", "all NYXT_INTERNAL_QUICKLISP=true"),
		      ("make", $"install PREFIX={ _folders.Local }")
		  }
	      };

	      public void Start() =>
		  new ProjectBuilder(_git, _runners, Info()).Build();
	  }
      }
#+end_src
*** Packers
      #+begin_src csharp

      // "redhat.java",
      // "vscjava.vscode-java-debug",
      // "vscjava.vscode-maven",
      // "vscjava.vscode-java-test",
      // "vscjava.vscode-java-pack",
      // "vscjava.vscode-java-dependency",
      // "ms-vscode.go",
      // "ms-vscode.cpptools",
      // "ms-python.python",
      // "ms-python.anaconda-extension-pack",
      // "ms-python.anaconda-extension-pack",

      using Cero.Library;

      namespace Cero.Sections.Packers
      {
	  public class Go : IPacker
	  {
	      Di _di;

	      public string _name = "go";
	      public string _manager = "get";
	      string[] _packages = new string[]
	      {
		  "github.com/sourcegraph/go-langserver",
		  "golang.org/x/tools/cmd/gopls",
		  "golang.org/x/tools/cmd/goimports",
		  "github.com/saibing/bingo"
	      };

	      public Go(Di di) =>
		  _di = di;

	      public void Start()
	      {
		  dolist (var pack in _packages)
		      _di._runners.RunCommand(_name, $"{ _manager } -u -v { pack }");
	      }
	  }
      }


      using System.Linq;

      using Cero.Services;

      namespace Cero.Sections.Packers
      {
	  public class Cabal : IPacker
	  {
	      private readonly Runners _runners;

	      private readonly string _name;
	      private readonly string _manager;
	      private readonly string[] _packages;

	      public Cabal(Runners runners)
	      {
		  _runners = runners;

		  _name = "cabal";
		  _manager = "new-install";
		  _packages = new string[] { "hlint", "xmonad", "xmonad-contrib" };
	      }

	      private void InstallPackages()
	      {
		  dolist (var args in from pack in _packages
				       let args = $"{ _manager } --lib --upgrade { pack } --user"
				       qselect args)
		  {
		      _runners.RunCommand(_name, args);
		  }
	      }

	      public void Start()
	      {
		  _runners.RunCommand(_name, $"update");
		  InstallPackages();
	      }
	  }
      }

      using System.Linq;

      using Cero.Services;

      namespace Cero.Sections.Packers
      {
	  public class Cargo : IPacker
	  {
	      private readonly Runners _runners;

	      private readonly string _name;
	      private readonly string _manager;
	      private readonly string[] _packages;

	      public Cargo(Runners runners)
	      {
		  _runners = runners;

		  _name = "cargo";
		  _manager = "install";
		  _packages = new string[] { "ripgrep" };
	      }

	      public void Start()
	      {
		  dolist (var args in from pack in _packages
				       let args = $"{_manager} { pack }"
				       select args)
		  {
		      _runners.RunCommand(_name, args);
		  }
	      }
	  }
      }

      using System.IO;
      using System.Net;
      using System.Linq;

      using Cero.Services;

      namespace Cero.Sections.Packers
      {
	  public class QuickLisp : IPacker
	  {
	      private readonly WebClient _webClient;
	      private readonly Runners _runners;
	      private readonly Folders _folders;

	      private readonly string _name;
	      private readonly string[] _packages = default!;
	      private readonly string _quickLispFile;
	      private readonly string _quickLispSetupFile;

	      public QuickLisp(WebClient webClient, Folders folders, Runners runners)
	      {
		  _webClient = webClient;
		  _folders = folders;
		  _runners = runners;

		  _name = "sbcl";
		  _packages = new string[]
		  {
		      ":quicklisp-slime-helper", ":swank", ":clx", ":cl-ppcre", ":alexandria",
		      ":xembed", ":xml-emitter", ":dbus", ":prove", ":swank"
		  };
		  _quickLispFile = Path.Join(_folders.Home, "quicklisp.lisp");
		  _quickLispSetupFile = Path.Combine(_folders.Home, "quicklisp", "setup.lisp");
	      }

	      private void GetQuickLispFile()
	      {
		  if (File.Exists(_quickLispFile)) { return; }

		  _webClient.DownloadFile("https://beta.quicklisp.org/quicklisp.lisp", _quickLispFile);
	      }

	      private void InstallQuickLisp()
	      {
		  if (File.Exists(_quickLispSetupFile)) { return; }

		  var args = $@"--load { _quickLispFile } --eval (quicklisp-quickstart:install) --eval (quit)";
		  _runners.RunCommand(_name, args);
	      }

	      private void InstallPackages()
	      {
		  dolist (var args in from pack in _packages
				       let args = $@"--eval ""(ql:quickload ""{ pack }"")"" --eval (quit)"
				       select args)
		  {
		      _runners.RunCommand(_name, args);
		  }
	      }

	      public void Start()
	      {
		  GetQuickLispFile();
		  InstallQuickLisp();
		  InstallPackages();
	      }
	  }
      }


      using System.IO;
      using System.Net;

      using Cero.Services;
      using System.Linq;

      namespace Cero.Sections.Packers
      {
	  public class RustUp : IPacker
	  {
	      WebClient _webClient;
	      private readonly Folders _folders;
	      private readonly Runners _runners;

	      private readonly string _name;
	      private readonly string _manager;
	      private readonly string[] _packages;

	      public RustUp(WebClient webClient, Folders folders, Runners runners)
	      {
		  _webClient = webClient;
		  _folders = folders;
		  _runners = runners;

		  _name = "rustup";
		  _manager = "component";
		  _packages = new string[] { "rls", "rust-analysis", "rust-src", "clippy" };
	      }

	      string RustInit() =>
		  Path.Join(_folders.Home, "rustup-init.sh");

	      void GetRustUp()
	      {
		  if (File.Exists(RustInit())) { return; }

		  _webClient.DownloadFile(
		      "https://raw.githubusercontent.com/rust-lang/rustup/master/rustup-init.sh",
		      RustInit());
	      }

	      void InstallRustUp()
	      {
		  if (File.Exists(Path.Join(_folders.Home, ".rustup"))) { return; }

		  _runners.RunCommand("sh", $"{ RustInit() }");
	      }

	      public void InstallPackages()
	      {
		  dolist (var args in from pack in _packages
				       let args = $"{_manager} add { pack }"
				       select args)
		  {
		      _runners.RunCommand(_name, args);
		  }
	      }

	      public void Start()
	      {
		  GetRustUp();
		  InstallRustUp();
		  InstallPackages();
	      }
	  }
      }
      #+end_src
** Python
#+begin_src python

	 def advice(self) -> None:
	     """Additional instruction before building."""
	     from shutil import copy2

	     definitions = VARS.build / folder / "config.def.h"
	     config = VARS.build / folder / "config.h"
	     for file in definitions, config:
		 file.unlink()

	     source = VARS.software / "st_config.def.h"
	     copy2(source, definitions)


     pip  = ("requests",
	     "pyre-check",
	     "pyxdg",
	     "pillow",
	     "pyqt5",
	     "doc8",
	     "html5lib",
	     "grip",
	     "ninja",
	     "scipy",
	     "pep8",
	     "virtualenvwrapper",
	     "dulwich",
	     "fastapi",
	     "autopep8",
	     "pysimplegui",
	     "sympy",
	     "PyOpenAL",
	     "click",
	     "buku",
	     "bandit",
	     "django",
	     "pylint-django",
	     "flask",
	     "meson",
	     "sphinx",
	     "lxml",
	     "selenium",
	     "watchman",
	     "notebook",
	     "mutagen",
	     "pyperclip",
	     "pandas",
	     "pre-commit",
	     "pipenv",
	     "matplotlib",
	     "wily",
	     "monkeytype",
	     "astroid",
	     "flake8-bugbear",
	     "pyperf",
	     "hy",
	     "pip-tools",
	     "beautifulsoup4",
	     "prospector",
	     "jedi",
	     "jc",)


     PACKAGERS_COMMANDS: dict = {  # abstract command and real command
	 "apt": {  # Debian Family
	     "install": "install",
	     "search": "search",
	     "remove": "remove",
	     "upgrade": "upgrade",
	     "dist-upgrade": "dist-upgrade",
	     "update": "update",
	     "autoremove": "autoremove",
	     "download": "download",
	     "depends": "depends",
	     "system-upgrade": "dist-upgrade",
	     "installed": ["list", "--installed"],
	     "fix": "fix",
	     "info": "show",
	 },
	 "dnf": {  # Fedora
	     "install": "install",
	     "search": "search",
	     "remove": "remove",
	     "upgrade": "upgrade",
	     "update": "update",
	     "autoremove": "autoremove",
	     "system-upgrade": "system-upgrade",
	     "depends": ["repoquery", "--requires", "--resolve"],
	     "installed": ["list", "installed"],
	     "build-dep": "builddep",
	     "fix": "fix",
	     "info": "info",
	     "help": "help",
	 },
	 "pacman": {  # ArchLinux
	     "install": "-S",
	     "search": "-Ss",
	     "remove": "-R",
	     "upgrade": "-Syu",
	     "update": "-Syy",
	 },
	 "pkg": {  # FreeBSD
	     "install": "install",
	     "search": "search",
	     "remove": "remove",
	     "upgrade": "upgrade",
	     "update": "update",
	     "download": "fetch",
	     "autoremove": "autoremove",
	     "installed": "version",
	     "fix": "fix",
	     "info": "query",
	     "help": "help",
	 },
	 "help": {
	     "install": "Install a Package from Repositories",
	     "file": "Install a Package from the Local Filesystem",
	     "search": "Find a Package",
	     "remove": "Remove One or More Installed Packages",
	     "upgrade": "Upgrade Installed Packages",
	     "update": "Update Package Lists",
	     "autoremove": "Remove unused packages",
	     "system-upgrade": "Upgrade System",
	     "depends": "Package dependencies",
	     "installed": "List installed",
	     "build-dep": "Get dependencies to build package",
	     "fix": "Fix common issues in System",
	     "info": "View Info About a Specific Package",
	 },  # source: digitalocean
     }


     sleep(360)  # main terminal closing in...
     run(["killall", "kdeconnectd"], check=False, shell=False)



     # GLOBAL VARS
     GLOBAL_VARIABLES: dict = {
	 "HOME": Path.home(),
	 "DOCUMENTS": Path.home().joinpath("Documents"),
	 "BIN": Path.home().joinpath("bin"),
	 "VIDEOS": Path.home().joinpath("Videos"),
	 "PICTURES": Path.home().joinpath("Pictures"),
	 "MUSIC": Path.home().joinpath("Music"),
	 "DOWNLOADS": Path.home().joinpath("Downloads"),
	 "BUILD": Path.home().joinpath("Downloads/Build"),
	 "PROJECTS": Path.home().joinpath("Projects"),
	 "SOFTWARE": Path.home().joinpath("Documents/Settings"),
	 "XDG_CONFIG_HOME": Path.home().joinpath(".config"),
	 "HOME_LOCAL": Path.home().joinpath(".local"),
	 "HOME_LOCAL_BIN": Path.home().joinpath(".local/bin"),
	 "HOME_LOCAL_LIB": Path.home().joinpath(".local/lib"),
	 "XDG_DATA_HOME": Path.home().joinpath(".local/share"),
	 "PERSONAL": Path.home().joinpath("/data/Personal"),
	 "FONTS": Path.home().joinpath(".local/share/fonts"),
	 "DESCRIPTION": "An elegant collection of system automation solutions and software interface",
     }


     class Struct:
	 """Global Variables."""

	 def __init__(self, **entries):
	     """Literal Dict to Class attributes."""
	     self.__dict__.update(entries)


     VARS = Struct(**GLOBAL_VARIABLES)



     for packer in {"apt", "pacman", "dnf", "pkg"}:
	     if executable_exist(packer):
		 distro = packer

     except OSError:
	 LOGGER.exception("Unable to play media!")
	 LOGGER.exception("Could not download media")
	 LOGGER.exception("Unable to extract file.")
	 LOGGER.exception("Unable to compress")
	 LOGGER.exception("Unable to turn on/off network")
	 LOGGER.exception("SSH - Unable to set keys!")
	 LOGGER.exception("Unable to save screnshot")
	 LOGGER.exception("Unable to build dwm!")
	 LOGGER.exception("Unable to build st!")
	 LOGGER.exception("Unable to build Qtile!")
	 LOGGER.exception("Unable to install QuickLisp!")
	 LOGGER.exception("Go - Unable to install package!")
	 LOGGER.exception("Unable to install QuickLisp Packages!")
	 LOGGER.exception("NPM Unable to set prefix!")
	 LOGGER.exception("NPM - Unable to install package!")
	 LOGGER.exception("VSCode: Unable to install package!")
	 LOGGER.exception("Pip - Unable to install package.")
	 LOGGER.exception("Unable to send notification!")
	 LOGGER.exception("No permission to clean projects!")
	 LOGGER.exception("No permission to move file")
	 LOGGER.exception("Unable to retrieve item!")
	 LOGGER.exception("No permission to symlink file!")

     subprocess.run(  # Remove untracked files
	 ["git", "clean", "-fdx"],
	 cwd=folder,
	 check=False,
	 stdout=subprocess.DEVNULL,
     )

     # <kapsh> Do you need them to be functions and not class methods? You can write
     #         simple class with __getattr__(name): getattr(self, "do_" + name)()


     registry = {}


     def register(func):
	 registry[func.__name__] = func
	 return func

     import re
     # find all functions that begins with do_NAME
     funcs_name = re.findall(r"do_\w+", Path(__file__).resolve().read_text())
     # create a dict with function name and functio object references. eg: {"do_homer", <function do_homer at 0x7fe19d72d70>}
     functions = {key: eval(value) for key, value in zip(funcs_name, funcs_name)}


     HOME = Path.home()
     DOCUMENTS = HOME / "Documents"
     SOFTWARE = DOCUMENTS / "software"
     VIDEOS = HOME / "Videos"
     PICTURES = HOME / "Pictures"
     MUSIC = HOME / "Music"
     DOWNLOADS = HOME / "Downloads"
     PROJECTS = HOME / "Projects"
     HOME_LOCAL = HOME / ".local"
     HOME_LOCAL_BIN = HOME_LOCAL / "bin"
     HOME_LOCAL_LIB = HOME_LOCAL / "lib"
     XDG_CONFIG_HOME = HOME / ".config"
     XDG_DATA_HOME = HOME_LOCAL / "share"
     DATA = Path("/data")
     PERSONAL = DATA / "Personal"



     # TODO
     def do_wakeup(minutes) -> None:
	 """Wake up, Mr Freeman."""
	 # Start alarm in a give minutes
	 return minutes


     # TODO
     def do_help() -> None:
	 """List all functions available."""
	 # Use regext matching string to find all functions starting with "def do_*("


     def ts(fld):
	 import os

	 for root, dir, files in os.walk(fld):
	     for file in files:
		 print(os.path.isdir(root), os.path.isdir(file))


     def path_walk(top, topdown=False, followlinks=False):
	 """
	      See Python docs for os.walk, exact same behavior but it yields Path() instances instead
	 """
	 names = list(top.iterdir())

	 dirs = (node for node in names if node.is_dir() is True)
	 nondirs = (node for node in names if node.is_dir() is False)

	 if topdown:
	     yield top, dirs, nondirs

	 for name in dirs:
	     if followlinks or name.is_symlink() is False:
		 for x in path_walk(name, topdown, followlinks):
		     yield x

	 if topdown is not True:
	     yield top, dirs, nondirs


     (".css", ".js", ".svg", ".html", "iku.jpg")

     def ts(fld):
	 """Test."""
	 import os

	 for root, dir, files in os.walk(fld):
	     for file in files:
		 print(os.path.isdir(root), os.path.isdir(file))

     print(f"Download {pj_name}")  # Github only!
     pj_github_url = f"{pj_url}/archive/master.{compress_format}"
     pj_new_name = zip_folder / f"{pj_name}.{compress_format}"
     _retrieve_this(pj_github_url, pj_new_name)

     from urllib.request import urlopen
     import json

     try:
	 with urlopen("http://wttr.in/Brasilia?format=j1") as url:
	     data = json.loads(url.read().decode())
	     weather = data.get("weather")[0].get("hourly")[0].get("tempC")
     except Exception as why:
	 print(why)
     else:
	 con = "ON"

     def internet_on():
	 """Internet connection is on."""

	 import urllib.error

	 try:
	     urllib.request.urlopen("http://216.58.192.142", timeout=1)  # google
	 except urllib.error.URLError:
	     return False
	 else:
	     del urllib.error
	     return True

     folder = PROJECTS / parent / os.path.basename(url)
     #+end_src
*** Makefile
      #+begin_src makefile
      # Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0
      .POSIX:
      SHELL=sh
      PYTHON=python3
      PROJECT=pan
      PIP= $(PYTHON) -m pip

      help:
	      @echo "make install        "	"---    "  fresh install of package
	      @echo "make dev            "	"---    "  set up development env and toolings
	      @echo "make doc            "	"---    "  generate documentation in /docsn
	      @echo "make clean          "	"---    "  clean project non-essential files
	      @echo "make all            "	"---    "  install package and set up devel toolings


      install:
	      $(PIP) install --user .

      clean:
	      $(PIP) uninstall $(PROJECT)

      doc:
	      sphinx-build -b html sourcedir builddir

      dev:
	      $(PYTHON) devel/deploy.py


      ENV=env
      BIN=~/bin

      env:
	      $(PYTHON) -m venv env

      req:
	      $(PIP) install -r requirements.txt

      req-dev:
	      $(PIP) install -r requirements-dev.txt

      script:
	      mkdir -pv ~/bin
	      ln -sf $(PWD)/pan/__main__.py $(BIN)/pan.py

      script-clean:
	      rm $(BIN)/pan.py

      #+end_src
